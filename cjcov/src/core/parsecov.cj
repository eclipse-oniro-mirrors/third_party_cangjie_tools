// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjcov.core

import std.fs.*
import std.regex.*
import std.collection.*
import stdx.log.*
import stdx.logger.*
import std.convert.*
import std.math.*
import cjcov.util.*

let GCOV_SPLIT_NUM = 4
let GCOV_SEGMENT_SOURCE_PATH = 3
let GCOV_SOURCE_SEGMENT_NUM = 2
let CJCOV_GCOV_LOG = getSep() + "cjcov_logs" + getSep() + "gcov_parse.log"
let CJCOV_MAIN_LOG = getSep() + "cjcov_logs" + getSep() + "cjcov.log"

public struct GcovData {
    var noncode = ArrayList<Int64>()
    var uncovered = ArrayList<Int64>()
    var covered = ArrayList<Int64>()
    var branches = HashMap<Int64, HashMap<Int64, Int64>>()
}

public class CoverageData {
    var srcFileName: String
    var uncovered: ArrayList<Int64>
    var covered: ArrayList<Int64>
    var branches: HashMap<Int64, HashMap<Int64, Int64>>
    var noncode: ArrayList<Int64>
    var allLines: ArrayList<Int64>

    public init(
        srcFileName: String,
        gcovData: GcovData
    ) {
        this.srcFileName = srcFileName
        this.uncovered = gcovData.uncovered
        this.covered = gcovData.covered
        this.branches = gcovData.branches
        this.noncode = gcovData.noncode
        this.allLines = uncovered.clone()
        this.allLines.add(all: covered)
    }
    func coverage(showBranch!: Bool = false): (Int64, Int64, Float64) {
        var total = 0
        var cover = 0

        if (!showBranch) {
            total = this.allLines.size
            cover = this.covered.size
            return (total, cover, calculateCoverage(cover, total))
        }

        for (line in this.branches.keys()) {
            for (branch in this.branches[line].keys()) {
                total += 1
                if (this.branches[line][branch] > 0) {
                    cover += 1
                }
            }
        }

        return (total, cover, calculateCoverage(cover, total))
    }

    func getSrcFileName() {
        return this.srcFileName
    }

    func getRelSrcFileName(options: Command): String {
        var RelSrcFileName = ""
        var basePath = options.rootArr[0]

        for (source in options.sourceArr) {
            if (this.srcFileName.startsWith(source)) {
                basePath = source
                break
            }
        }

        for (root in options.rootArr) {
            if (this.srcFileName.startsWith(root)) {
                basePath = root
                break
            }
        }

        try {
            RelSrcFileName = getRelPath(this.srcFileName, basePath)
        } catch (e: Exception) {
            eprintln("get relative path for ${this.srcFileName} failed, base path: ${basePath}.")
            return ""
        }
        return RelSrcFileName
    }
}

func calculateCoverage(cover: Int64, total: Int64, defaultValue!: Float64 = 0.0) {
    // The file does not have branches or lines of code are normal
    if (total == 0) {
        return defaultValue
    }

    if (cover == 0) {
        return defaultValue
    }

    return round(Float64(1000) * Float64(cover) / Float64(total)) / Float64(10)
}

public func processDatafile(dataPath: String, options: Command, logger: SimpleLogger): Bool {
    var dataPathc = canonicalize(dataPath).toString();
    if (existSpecificSymbol(dataPathc)) {
        eprintln("path check failed. ${dataPathc} contains injecting relevant special characters.")
        return false
    }
    let (dirname, fname) = segmentFileNameAndPath(dataPath)

    // "--preserve-paths" will get a long file name which joined in absolute path,
    // so using relative path to generate file name default
    let execTool: String = "llvm-cov"
    let arguments = ArrayList<String>(["gcov", fname, "-l", "-x"])
    if (options.branches) {
        arguments.add("--branch-counts")
        arguments.add("--branch-probabilities")
    }

    if (options.verbose) {
        let cmdStr: String = execTool + " " + String.join(arguments.toArray(), delimiter: " ")
        logger.log(LogLevel.INFO, cmdStr)
    }

    let (flag, outStr, errStr) = subprocessCallWithOutput(execTool, arguments, workingDirectory: Path(dirname))
    if (!flag) {
        eprintln("llvm-cov gcov failed, datafile: ${dataPath}, output:\n${errStr}${outStr}")
        return false
    }

    if (options.verbose) {
        logger.log(LogLevel.INFO, errStr + outStr)
    }

    return true
}

public func printCoverageData(options: Command, gcovFile: String, gcovData: GcovData) {
    let fs = File(options.output + CJCOV_GCOV_LOG, OpenMode.Append);
    let logger: SimpleLogger = SimpleLogger(fs)
    logger.level = LogLevel.ALL

    /*
       If get the --verbose option, the report data showed as followsï¼š
       ==================== start: covdata =====================

       noncode line numbers:
       [22, 28, 34]

       uncovered line numbers:
       [2, 3, 4]

       covered data:
       [("5", 1), ("32", 10), ("33", 1)]

       branches data:
       line number:    8  ==>  data: [("0", 10), ("1", 1)]
       line number:   10  ==>  data: [("0", 10), ("1", 1)]

       ===================== end: covdata =======================
     */
    if (options.verbose) {
        logger.log(LogLevel.INFO, "\n==================== start: ${gcovFile} =====================\n")
        logger.log(LogLevel.INFO, "noncode line numbers: \n${gcovData.noncode}\n")
        logger.log(LogLevel.INFO, "uncovered line numbers: \n${gcovData.uncovered}\n")
        logger.log(LogLevel.INFO, "covered  line numbers: \n${gcovData.covered}\n")
        logger.log(LogLevel.INFO, "branches data:")
        for ((line, data) in gcovData.branches) {
            logger.log(LogLevel.INFO, "line number:" + line.format("5") + "  ==>  data: ${data}")
        }

        logger.log(LogLevel.INFO, "\n===================== end: ${gcovFile} =======================\n")
    }

    logger.close()
    fs.close()
    return
}

func processGcovBranch(lineno: Int64, line: String, branches: HashMap<Int64, HashMap<Int64, Int64>>): Bool {
    var branchSubMap = HashMap<Int64, Int64>()
    var lineStr = line.trimAscii()
    var fields = lineStr.split(" ", removeEmpty: true)
    var branchField = Int64.parse(fields[1])

    if (branches.contains(lineno)) {
        branchSubMap = branches[lineno].clone()
    }

    // "branch  xxx never executed", if gcov showed like this, the branch count show be assigned as 0.
    branchSubMap[branchField] = Int64.tryParse(fields[3]) ?? 0
    branches[lineno] = branchSubMap
    return true
}

func foundSourceFile(srcFileNameOrigin: String, gcovFile: String, options: Command, logger: SimpleLogger): String {
    // If it is an absolute path, just check if the file exists.
    if (srcFileNameOrigin.isEmpty()) {
        logger.log(LogLevel.WARN, "${srcFileNameOrigin} does not exist, it is read from ${gcovFile}")
        return ""
    }

    if (Path(srcFileNameOrigin).isAbsolute()) {
        if (!exists(srcFileNameOrigin)) {
            logger.log(LogLevel.WARN, "${srcFileNameOrigin} does not exist, it is read from ${gcovFile}")
            return ""
        }

        return toCanonical(srcFileNameOrigin)
    }

    // If it is a relative path, first find the source file through the path of the gcov file,
    // secondly look for it through the --source path passed in by the user,
    // thirdly look for it through the --root path passed in by the user
    var (gcovrDir, _) = segmentFileNameAndPath(gcovFile)
    var srcFileName = gcovrDir + getSep() + srcFileNameOrigin
    if (!exists(srcFileName)) {
        var found_flag = false
        var pathArr: ArrayList<String> = ArrayList<String>()
        pathArr.add(all: options.sourceArr)
        pathArr.add(all: options.rootArr)
        for (path in pathArr) {
            srcFileName = path + getSep() + srcFileNameOrigin
            if (exists(srcFileName)) {
                found_flag = true
                break
            }
        }

        if (!found_flag) {
            logger.log(
                LogLevel.WARN,
                "${srcFileName} does not exist, it is read from ${gcovFile}, relative source: ${srcFileNameOrigin}"
            )
            return ""
        }
    }

    return toCanonical(srcFileName)
}

func supportPathRegex(path: String, srcPath: String): Bool {
    var pattern = path.replace(#"\"#, #"\\"#).replace(".", #"\."#).replace("*", ".*")
    match (Regex(pattern).matcher(srcPath).fullMatch()) {
        case Some(_) => return true
        case None => return false
    }
}

func parseGcovHead(gcovFile: String, options: Command, logger: SimpleLogger): (Bool, String, Array<String>) {
    var srcFileName = ""
    var fileLines = getFileLines(gcovFile)
    var firstLine = fileLines[0]
    var segments = firstLine.split(":", GCOV_SPLIT_NUM)

    // The format of the first line should be -: 0:Source:${srcFilePath} format,
    // if it is not in this format, it means that it is not a gcov file, return error
    if (segments.size != GCOV_SPLIT_NUM ||
        !segments[GCOV_SOURCE_SEGMENT_NUM].toAsciiLower().trimAscii().startsWith("source")) {
        eprintln("Fatal error parsing gcov file, line 1:${firstLine}")
        return (false, "", fileLines)
    }

    srcFileName = foundSourceFile(segments[GCOV_SEGMENT_SOURCE_PATH].trimAscii(), gcovFile, options, logger)
    if (srcFileName.size == 0) {
        return (true, "", fileLines)
    }

    // If source file is a directory, skip processing the gcov file.
    if (!fileExists(srcFileName)) {
        return (true, "", fileLines)
    }

    for (excludePath in options.excludeArr) {
        if (srcFileName.startsWith(excludePath)) {
            // If the path of source file is in the exclude list, skip the processing of this file.
            return (true, "", fileLines)
        }

        if (supportPathRegex(excludePath, srcFileName)) {
            return (true, "", fileLines)
        }
    }

    if (options.includeArr.size > 0) {
        var isInList = false
        for (includePath in options.includeArr) {
            if (srcFileName.startsWith(includePath)) {
                isInList = true
                break
            }

            if (supportPathRegex(includePath, srcFileName)) {
                isInList = true
            }
        }

        if (!isInList) {
            return (true, "", fileLines)
        }
    }

    return (true, srcFileName, fileLines)
}

func processGcovBody(lines: Array<String>): (Bool, GcovData) {
    var gcovData = GcovData()
    var lineno: Int64 = -1
    for (line in lines[1..]) {
        var newLine = line.trimAscii()
        if (newLine.size == 0) {
            continue
        }

        var segments = newLine.split(":", 3)
        var first = segments[0].trimAscii()
        if (first.startsWith("call") || first.startsWith("function") || (first[0] == UInt8(UInt32(r'=')))) {
            continue
        }

        if (segments.size > 1) {
            lineno = Int64.tryParse(segments[1].trimAscii()) ?? -1
            if (lineno == -1) {
                eprintln("can not get line number, line: ${line}}")
                return (false, gcovData)
            }
        }

        if (first[0] == UInt8(UInt32(r'-')) || newLine.contains("@Test")) {
            gcovData.noncode.add(lineno)
        } else if (first[0] == UInt8(UInt32(r'#'))) {
            gcovData.uncovered.add(lineno)
        } else if (first[0] >= UInt8(UInt32(r'0')) && first[0] <= UInt8(UInt32(r'9'))) {
            var num = Int64.tryParse(first) ?? -1
            if (num == -1) {
                eprintln("cat not get hit times, line: ${line}, first segment: ${first}")
                return (false, gcovData)
            }
            gcovData.covered.add(lineno)
        } else if (first.startsWith("branch")) {
            var ret = processGcovBranch(lineno, line, gcovData.branches)
            if (!ret) {
                eprintln("process branches info failed.")
                return (false, gcovData)
            }
        } else {
            eprintln("unrecognized gcov output, linestr: ${line}")
            return (false, gcovData)
        }
    }

    return (true, gcovData)
}

func mergeAllGcovData(allGcovData: HashMap<String, ArrayList<GcovData>>): HashMap<String, GcovData> {
    var allMergeDatas: HashMap<String, GcovData> = HashMap<String, GcovData>()
    for ((srcFilePath, gcovDatas) in allGcovData) {
        allMergeDatas[srcFilePath] = mergeGcovData(gcovDatas)
    }
    return allMergeDatas
}

public func writeReadMeNoValidSrc(fpath: String) {
    let str = ###"If no valid source files are found, the possible reasons are as follows:
1. The source file does not exist.
2. The gcno file and the gcda file need to be placed in the same path and do not change the path of the gcno and gcda files after the compilation is completed.
3. There is a special case: all Cangjie files only define global variables. If a source file has only global variables, the file will not be counted in the coverage data.
"###
    File.writeTo(fpath, unsafe { str.rawData() })

    return
}

public func processAllGcov(gcovFiles: HashSet<String>, options: Command): HashMap<String, GcovData> {
    var mergeData: HashMap<String, GcovData> = HashMap<String, GcovData>()
    var allGcovData: HashMap<String, ArrayList<GcovData>> = HashMap<String, ArrayList<GcovData>>()
    let fs = File(options.output + CJCOV_MAIN_LOG, OpenMode.Append);
    let logger: SimpleLogger = SimpleLogger(fs)
    logger.level = LogLevel.ALL
    var foundSrcFileFlag = false

    for (gcovFile in gcovFiles) {
        var (ret_head, srcFileName, lines) = parseGcovHead(gcovFile, options, logger)
        if (!ret_head) {
            logger.log(LogLevel.WARN, "parse gcov file header failed, gcov file: ${gcovFile}")
            continue
        }

        // It is normal if source file can not be found, if --verbose is assigned,  gcov files which are skipped will be showed.
        if (srcFileName.size == 0) {
            continue
        }

        // Set flag to true if any source file is found.
        foundSrcFileFlag = true

        // Cangjie does not support usage such as (xx, yy) = functionxxx(), which (xx, yy) are declared before
        var (retBody, gcovData) = processGcovBody(lines)
        if (!retBody) {
            logger.log(LogLevel.WARN, "process gcov body failed, gcov file: ${gcovFile}")
            continue
        }

        if (!allGcovData.contains(srcFileName)) {
            allGcovData[srcFileName] = ArrayList<GcovData>([gcovData])
        } else {
            allGcovData[srcFileName].add(gcovData)
        }
    }

    if (!foundSrcFileFlag) {
        let logPath = options.output + getSep() + "cjcov_logs" + getSep() + "cjcov.log"
        let readMeFile = options.output + getSep() + "cjcov_logs" + getSep() + "reason_for_no_valid_source"
        writeReadMeNoValidSrc(readMeFile)
        println(
            "Warning: no valid source files were found, please refer to the follow files:\n1. ${logPath}\n2. ${readMeFile}")
    }

    mergeData = mergeAllGcovData(allGcovData)
    logger.close()
    fs.close()
    return mergeData
}

public func mergeBranchData(data1: HashMap<Int64, Int64>, data2: HashMap<Int64, Int64>): HashMap<Int64, Int64> {
    var newData: HashMap<Int64, Int64> = data1.clone()
    for ((key, value) in data2) {
        if (!newData.contains(key)) {
            newData[key] = value
        } else {
            newData[key] = newData[key] + value
        }
    }
    return newData
}

func mergeGcovData(datas: ArrayList<GcovData>): GcovData {
    var allNonCode: HashSet<Int64> = HashSet<Int64>()
    var allUncovered: HashSet<Int64> = HashSet<Int64>()
    var allCovered: HashSet<Int64> = HashSet<Int64>()
    var allBranches: HashMap<Int64, HashMap<Int64, Int64>> = HashMap<Int64, HashMap<Int64, Int64>>()
    for (data in datas) {
        allNonCode.add(all: data.noncode)
        allUncovered.add(all: data.uncovered)
        allCovered.add(all: data.covered)
        for ((lineno, branchesMap) in data.branches) {
            if (!allBranches.contains(lineno)) {
                allBranches[lineno] = branchesMap
            } else {
                allBranches[lineno] = mergeBranchData(allBranches[lineno], branchesMap)
            }
        }
    }

    var newUncovered = allUncovered.clone()
    var newNonCode = allNonCode.clone()

    // If it is the same line number, the priority is covered, noncoverd, noncode.
    for (noncode in allNonCode) {
        if (allCovered.contains(noncode) || allUncovered.contains(noncode)) {
            newNonCode.remove(noncode)
        }
    }

    for (uncovered in allUncovered) {
        if (allCovered.contains(uncovered)) {
            newUncovered.remove(uncovered)
        }
    }

    var mergeData: GcovData = GcovData()
    mergeData.covered = ArrayList<Int64>(allCovered)
    mergeData.uncovered = ArrayList<Int64>(newUncovered)
    mergeData.noncode = ArrayList<Int64>(newNonCode)

    mergeData.covered.sortBy(comparator: cmpInt64, stable: true)
    mergeData.uncovered.sortBy(comparator: cmpInt64, stable: true)
    mergeData.noncode.sortBy(comparator: cmpInt64, stable: true)
    mergeData.branches = allBranches
    return mergeData
}

@When[backend == "cjnative"]
public func generateGcovFiles(options: Command): Bool {
    var gcnoFiles: HashSet<String> = HashSet<String>()
    for (path in options.rootArr) {
        // Non-recursively traverse all gcda files
        gcnoFiles.add(all: HashSet<String>(getAllFilesWithSuffix(path, ".gcno", true)))
    }
    if (gcnoFiles.size == 0) {
        println("There are no *.gcno files, coverage reports will not be generated.")
        return false
    }

    let fs = File(options.output + CJCOV_MAIN_LOG, OpenMode.Append);
    let logger: SimpleLogger = SimpleLogger(fs)
    logger.level = LogLevel.ALL

    for (gcnoFile in gcnoFiles) {
        var ret = processDatafile(gcnoFile, options, logger)
        if (!ret) {
            eprintln("process gcdafile: ${gcnoFile} failed.")
            logger.close()
            fs.close()
            return false
        }
    }

    logger.close()
    fs.close()
    return true
}

func fileExists(path: String): Bool {
    if (!exists(path)) {
        return false
    } else if (FileInfo(path).isRegular()) {
        return true
    } else if (FileInfo(path).isSymbolicLink()) {
        return FileInfo(canonicalize(path)).isRegular()
    }
    return false
}
