// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.config

import std.collection.*

import std.collection.{
    collectString,
    collectHashMap,
    HashMap,
    ArrayList
}

private enum Operation {
    | Prepend(String)
    | Append(String)
    | Replace(String)
    | Absent(String)
}

public class EnvironmentBuilder {
    @When[ os == "Windows" ]
    private static let SEPARATOR = ";"
    @When[ os != "Windows" ]
    private static let SEPARATOR = ":"

    private let operations = HashMap<String, ArrayList<Operation>>()

    private let casePreservation = HashMap<String, String>()

    @When[ os != "Windows" ]
    private func adjustForCaseSensitivity(s: String): String { s }

    @When[ os == "Windows" ]
    private func adjustForCaseSensitivity(s: String): String {
        let normalized = s.toAsciiUpper()
        if (!casePreservation.contains(normalized)) {
            casePreservation[normalized] = s
        }
        return casePreservation[normalized]
    }

    @When [ os == "Windows" ]
    private func beforeFinish(env: Collection<(String, String)>): HashMap<String, String> {
        // Because macro expansion is using linux runtime, environment variables are 
        // interpreted as case sensitive at macro expansion stage.
        // While at all other moments they interpreted as case insensitive.
        //
        // Thus the actual case of environment variable should never change!
        for ((k, _) in env) {
            let normalized = k.toAsciiUpper()
            if (
                let Some(metKey) <- casePreservation.get(normalized) &&
                let Some(ops) <- operations.remove(metKey)
            ) {
                operations[k] = ops
            }
        }
        env |> collectHashMap
    }


    public init() { }
    
    public func prepend(_name: String, value: String): Unit {
        let name = adjustForCaseSensitivity(_name)
        if (!operations.contains(name)) {
            operations[name] = ArrayList()
        }

        if (!value.isEmpty()) {
            operations[name].add(Prepend(value))
        }
    }

    public func prepend(name: String, iter: Iterable<String>): Unit {
        prepend(name, iter |> collectString(delimiter: SEPARATOR))
    }

    public func append(_name: String, value: String): Unit {
        let name = adjustForCaseSensitivity(_name)
        if (!operations.contains(name)) {
            operations[name] = ArrayList()
        }

        if (!value.isEmpty()) {
            operations[name].add(Append(value))
        }
    }

    public func append(name: String, iter: Iterable<String>): Unit {
        append(name, iter |> collectString(delimiter: SEPARATOR))
    }

    public func replace(_name: String, value: String): Unit {
        let name = adjustForCaseSensitivity(_name)
        operations[name] = ArrayList([Replace(value)])
    }

    public func replace(name: String, iter: Iterable<String>): Unit {
        replace(name, iter |> collectString(delimiter: SEPARATOR))
    }

    public func setIfAbsent(_name: String, value: String): Unit {
        let name = adjustForCaseSensitivity(_name)
        if (!operations.contains(name)) {
            operations[name] = ArrayList()
        }

        if (operations[name].size == 0 && !value.isEmpty()) {
            operations[name].add(Absent(value))
        }
    }

    public func setIfAbsent(name: String, iter: Iterable<String>): Unit {
        setIfAbsent(name, iter |> collectString(delimiter: SEPARATOR))
    }

    public func asCliStrings(originalEnv: Collection<(String, String)>): HashMap<String, String> {
        let originalEnvMap = originalEnv |> collectHashMap
        let result = HashMap<String, String>()
        func addEnvVar(env: String): Unit {
            if (originalEnvMap.contains(env) && !result.contains(env)) {
                result[env] = asVar(env)
            }
        }

        for ((env, ops) in operations) {
            for (op in ops) {
                match (op) {
                    case Prepend(val) => addEnvVar(env); prependValue(result.entryView(env), val)
                    case Append(val) => addEnvVar(env); appendValue(result.entryView(env), val)
                    case Replace(val) => result[env] = val
                    case Absent(val) => 
                        if (!originalEnvMap.contains(env)) {
                            result[env] = val
                        }
                }
            }
        }
        result
    }

    @When[ os != "Windows" ]
    public func finish(originalEnv: Collection<(String, String)>): HashMap<String, String> {
        let result = originalEnv |> collectHashMap

        for ((env, ops) in operations) {
            for (op in ops) {
                match (op) {
                    case Prepend(val) => prependValue(result.entryView(env), val)
                    case Append(val)  => appendValue(result.entryView(env), val)
                    case Replace(val) => result[env] = val
                    case Absent(val)  =>
                        if (!result.contains(env)) {
                            result[env] = val
                        }
                }
            }
        }
        result
    }

    @When[os == "Windows"]
    public func finish(originalEnv: Collection<(String, String)>): HashMap<String, String> {
        let result = beforeFinish(originalEnv)
        var metPath: ?String = None

        for ((env, ops) in operations) {
            for (op in ops) {
                match (op) {
                    case Prepend(val) => prependValue(result.entryView(env), val)
                    case Append(val) => appendValue(result.entryView(env), val)
                    case Replace(val) => result[env] = val
                    case Absent(val) =>
                        if (!result.contains(env)) {
                            result[env] = val
                        }
                }
            }
            if (env.toAsciiUpper() == "PATH" && metPath.isNone()) {
                metPath = env
            }
        }

        if (let Some(varname) <- metPath) {
            let tmp = result[varname]
            result["PATH"] = tmp
            result["path"] = tmp
            result["Path"] = tmp
        }

        result
    }

    @When[ os == "Windows" ]
    private static func asVar(v: String): String { "%${v}%" }
    @When[ os != "Windows" ]
    private static func asVar(v: String): String { "$${v}" }

    private static func appendValue(view: MapEntryView<String, String>, value: String): Unit {
        if (let Some(curr) <- view.value) {
            if (curr.endsWith(SEPARATOR)) {
                view.value = curr + value
            } else {
                view.value = curr + SEPARATOR + value
            }
        } else {
            view.value = value
        }
    }

    private static func prependValue(view: MapEntryView<String, String>, value: String): Unit {
        if (let Some(curr) <- view.value) {
            if (curr.startsWith(SEPARATOR)) {
                view.value = value + curr
            } else {
                view.value = value + SEPARATOR + curr
            }
        } else {
            view.value = value
        }
    }
}

extend EnvironmentBuilder {
    public static func fromEnvConfig(envConfig: HashMap<String, EnvInfo>): EnvironmentBuilder {
        let envBuilder = EnvironmentBuilder()
        for ((envName, envInfo) in envConfig) {
            match (envInfo.spliceType) {
                case ABSENT =>  envBuilder.setIfAbsent(envName, envInfo.envValue)
                case REPLACE => envBuilder.replace(envName, envInfo.envValue)
                case PREPEND => envBuilder.prepend(envName, envInfo.envValue)
                case APPEND =>  envBuilder.append(envName, envInfo.envValue)
                case _ => ()
            }
        }
        envBuilder
    }
}