{"caseFolder":"normalTest//CaptureOfVariables", "id":"9"}
{"jsonrpc":"2.0","id":"1","method":"initialize","params":{"processId":null,"rootPath":"D:/Work/projects/Iteration_5th/B055/UT","rootUri":"file:///d%3A/Work/projects/Iteration_5th/B055/UT/","capabilities":{"workspace":{"applyEdit":true,"workspaceEdit":{},"didChangeWatchedFiles":{},"symbol":{},"executeCommand":{},"workspaceFolders":false,"configuration":false},"textDocument":{"synchronization":{"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"completionItem":{"snippetSupport":true}},"hover":{},"signatureHelp":{},"references":{},"documentHighlight":{"dynamicRegistration":true},"formatting":{},"rangeFormatting":{},"onTypeFormatting":{},"definition":{},"codeAction":{},"documentLink":{},"rename":{"prepareSupport":true},"semanticHighlightingCapabilities":{"semanticHighlighting":true},"callHierarchy":{},"semanticTokens":{"tokenTypes":["namespace","type","class","enum","interface","struct","typeParameter","parameter","variable","property","enumMember","event","function","method","macro","keyword","modifier","comment","string","number","regexp","operator","member","label"],"tokenModifiers":["declaration","definition","readonly","static","deprecated","abstract","async","modification","documentation","defaultLibrary"],"dynamicRegistration":true}}}}}
{"jsonrpc":"2.0","method":"initialized","params":{}}
{"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///d%3A/Work/repo/Char/Fork/cangjie_language_server/test/testChr/normalTest/CaptureOfVariables/src/cature.cj","languageId":"Cangjie","version":1,"text":"// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.\n// This source file is part of the Cangjie project, licensed under Apache-2.0\n// with Runtime Library Exception.\n//\n// See https://cangjie-lang.cn/pages/LICENSE for license information.\n\nfunc CaptureFunc() {\r\n    /**\r\n    * this var xxxxx\r\n    */\r\n    var varXXX = 1\r\n    /**\r\n    * this let xxxxx\r\n    */\r\n    let letYYY = 2\r\n    /**\r\n    * this func ggggg\r\n    */\r\n    func closure() {\r\n        return varXXX + letYYY // OK, captured a mutable variable.\r\n    }\r\n\r\n    let b = closure  // Error, g cannot be assigned to a variable\r\n\r\n    closure    // Error, g cannot be used as an expression\r\n    closure()  // OK, g can be invoked\r\n\r\n    func g2() {\r\n        closure()        // OK, g2 also captured a mutable variable\r\n    }\r\n\r\n    let c = g2 // Error, g2 cannot be assigned to a variable\r\n\r\n    func h() {\r\n        return letYYY  // OK, captured an immutable variable.\r\n    }\r\n    let d = h    // OK, h can be assigned to variable\r\n\r\n    // Error, lambda captured a mutable variable,\r\n    //cannot be assigned to a variable\r\n    let e = { return varXXX }\r\n\r\n    // OK, lambda captured a mutable variable, can be invoked.\r\n    let i = { varXXX*varXXX }()\r\n\r\n    return closure  // Error, g cannot be used as a return value.\r\n}\r\n\r\n/*\r\n    捕获的局部变量必须满足以下规则：\r\n    • 被捕获的局部变量必须在闭包定义之前声明，否则编译报错；\r\n    • 变量被捕获时必须已经完成初始化，否则编译报错；\r\n    • 如果函数外有变量，同时函数内有同名的局部变量，函数内的闭包因局部变量的作用域未开始而捕获\r\n    了函数外的变量时，为避免用户误用，报warning；\r\n*/\r\n\r\n// 1. The captured variable must be defined before the closure.\r\nlet letGlobal_1 = 4\r\nfunc f_1() {\r\n    letGlobal_1 // Print 4.\r\n    let x_2 = 99\r\n    func f_1_1() {\r\n        return x_2\r\n    }\r\n    let f_2_2 = {\r\n        return x_2\r\n    }\r\n    f_1_1() // Print 99.\r\n    f_2_2() // Print 99.\r\n}\r\n\r\n// 2. The variable must be initialized before being captured.\r\nlet let_variable = 4\r\nfunc f_2() {\r\n    let_variable// Print 4.\r\n    let let_variable: Int64\r\n    func f_2_1() {\r\n        return let_variable  // Error: x is not initialized yet.\r\n    }\r\n    let_variable = 99\r\n    f_2_1()\r\n}\r\n// 3. If there is a local variable in a block, closures capture variables of the same name in the outer scope will report a warning.\r\nlet let_variable_1 = 4\r\nfunc f_3() {\r\n    let_variable_1 // Print 4.\r\n    func f_3_1() {\r\n        return let_variable_1 // warning\r\n    }\r\n    let f_3_2 = {\r\n        return let_variable_1 // warning\r\n    }\r\n    let let_variable_1 = 99\r\n    f_3_1() // print 4\r\n    f_3_2() // print 4\r\n}\r\n\r\n//全局变量、静态成员变量、实例成员变量的访问可以分为以下两种情形：\r\n//• 对于静态成员变量和全局变量在函数或lambda 中均可以访问；\r\n//• 实例成员函数将this 作为参数传入，因此在实例成员函数内可以通过this 访问所有的实例成员变量。\r\n//因此访问了var 修饰的全局变量、静态成员变量、实例成员变量的函数或lambda 仍可作为一等公民使\r\n//用。\r\n// 1. Static member variables and global variables can be accessed in functions.\r\nclass C {\r\n    static var a: Int32 = 0\r\n    static func foo() {\r\n        a++ // OK\r\n        return a\r\n    }\r\n}\r\nvar globalV1 = 0\r\nfunc countGlobalV1() {\r\n    globalV1++ // OK\r\n    C.a = 99 // OK\r\n    let g = C.foo // OK\r\n}"}}}
{"jsonrpc":"2.0","id":"9","method":"textDocument/references","params":{"textDocument":{"uri":"file:///d%3A/Work/repo/Char/Fork/cangjie_language_server/test/testChr/normalTest/CaptureOfVariables/src/cature.cj"},"position":{"line":22,"character":14},"context":{"includeDeclaration":true}}}
{"jsonrpc":"2.0","id":"1","method":"shutdown","params":{}}
{"jsonrpc":"2.0","method":"exit","params":{}}