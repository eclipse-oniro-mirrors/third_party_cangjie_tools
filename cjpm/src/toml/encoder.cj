// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

package cjpm.toml

import std.collection.*
import std.io.*
import stdx.serialization.serialization.*

public struct Encoder {
    let w: OutputStream
    let sb = StringBuilder()
    var tablesInline = false
    var arraysMultiline = false
    var indentSymbol = "  "
    var indentTables = false

    public init(w: OutputStream) {
        this.w = w
    }

    public func encode(tv: TomlValue): Unit {
        let key = Key()
        this.encode(key, tv)
        w.write(sb.toString().toArray())
        w.flush()
    }

    public func encode(dm: DataModel): Unit {
        let key = Key()
        let tv = dm.toToml()
        this.encode(key, tv)
        w.write(sb.toString().toArray())
        w.flush()
    }

    func encode(key: Key, tv: TomlValue): Unit {
        match (tv) {
            case v: TomlString => writeKeyValue(key, v, false)
            case v: TomlInteger => writeKeyValue(key, v, false)
            case v: TomlFloat => writeKeyValue(key, v, false)
            case v: TomlBoolean => writeKeyValue(key, v, false)
            case v: TomlOffsetDatetime => writeKeyValue(key, v, false)
            case v: TomlLocalDatetime => writeKeyValue(key, v, false)
            case v: TomlLocalDate => writeKeyValue(key, v, false)
            case v: TomlLocalTime => writeKeyValue(key, v, false)
            case v: TomlArray =>
                if (isTableArray(v)) {
                    this.encodeArrayOfTables(key, v)
                } else {
                    writeKeyValue(key, v, false)
                }
            case v: TomlObject => encodeTable(key, v)
            case _ => throw TomlException("not supported TomlValue ${tv}")
        }
    }

    func writeKeyValue(key: Key, tv: TomlValue, inline: Bool): Unit {
        if (key.size == 0) {
            throw TomlException("toml: top-level values must be maps or structs or class")
        }
        if (!tv.comment.isEmpty()) {
            this.sb.append(tv.comment.toString())
            this.newline()
        }
        this.sb.append("${indentStr(key)}${key.maybeQuoted(key.size - 1)} = ")
        this.encodeElement(tv)
        if (!inline) {
            this.newline()
        }
    }

    func encodeElement(tv: TomlValue): Unit {
        match (tv) {
            case v: TomlString => sb.append(v.toString())
            case v: TomlInteger => sb.append(v.toString())
            case v: TomlFloat => sb.append(v.toString())
            case v: TomlBoolean => sb.append(v.toString())
            case v: TomlOffsetDatetime => sb.append(v.toString())
            case v: TomlLocalDatetime => sb.append(v.toString())
            case v: TomlLocalDate => sb.append(v.toString())
            case v: TomlLocalTime => sb.append(v.toString())
            case v: TomlArray => encodeArrayOrSliceElement(v)
            case v: TomlObject => encodeMap(Key(), v, true)
            case _ => throw TomlException("not supported TomlValue ${tv}")
        }
    }

    func encodeArrayOrSliceElement(tv: TomlArray) {
        let length = tv.size
        this.sb.append('[')
        for (i in 0..length) {
            let elem = tv[i]
            this.encodeElement(elem)
            if (i != length - 1) {
                this.sb.append(", ")
            }
        }
        this.sb.append(']')
    }

    func encodeArrayOfTables(key: Key, tv: TomlArray) {
        if (key.size == 0) {
            throw TomlException("toml: top-level values must be maps or structs or class")
        }
        if (!tv.comment.isEmpty()) {
            this.sb.append(tv.comment.toString())
        }
        for (v in tv.value) {
            this.newline()
            this.sb.append("${indentStr(key)}[[${key}]]")
            this.newline()
            this.encodeMap(key, (v as TomlObject).into(), false)
        }
    }

    func encodeTable(key: Key, to: TomlObject) {
        if (key.size == 1) {
            this.newline()
        }
        if (key.size >= 2) {
            var hasChildObj = false
            for ((tk, tv) in to.value) {
                if (tv is TomlObject) {
                    hasChildObj = true
                    break
                }
            }
            if (hasChildObj) {
                if (!to.comment.isEmpty()) {
                    this.sb.append(to.comment.toString())
                    this.newline()
                }
                this.sb.append("${indentStr(key)}[${key}]")
                this.newline()

                this.encodeMap(key, to, false)
            } else {
                if (!to.comment.isEmpty()) {
                    this.sb.append(to.comment.toString())
                    this.newline()
                }
                this.sb.append("${indentStr(key)}${key.maybeQuoted(key.size - 1)} = ")
                encodeElement(to)
            }
        } else {
            if (key.size > 0) {
                if (!to.comment.isEmpty()) {
                    this.sb.append(to.comment.toString())
                    this.newline()
                }
                this.sb.append("${indentStr(key)}[${key}]")
                this.newline()
            }
            this.encodeMap(key, to, false)
        }
    }

    func writeMapKeys(mapKeys: ArrayList<String>, trailC: Bool, key: Key, to: TomlObject, inline: Bool): Unit {
        var i = 0
        for (mapKey in mapKeys) {
            let val = to[mapKey]
            if (inline) {
                this.writeKeyValue(Key([mapKey]), val, true)
                if (trailC || i != mapKeys.size - 1) {
                    this.sb.append(", ")
                }
            } else {
                this.encode(key.add(mapKey), val)
            }
            i++
        }
    }

    func encodeMap(key: Key, to: TomlObject, inline: Bool) {
        let mapKeysDirect = ArrayList<String>()
        let mapKeysSub = ArrayList<String>()
        for ((k, tv) in to.value) {
            if (isTable(tv)) {
                mapKeysSub.add(k)
            } else {
                mapKeysDirect.add(k)
            }
        }
        if (inline) {
            this.sb.append('{')
        }
        writeMapKeys(mapKeysDirect, mapKeysSub.size > 0, key, to, inline)
        writeMapKeys(mapKeysSub, false, key, to, inline)
        if (inline) {
            this.sb.append('}')
            this.newline()
        }
    }

    func hasSubObject(tv: TomlValue): Bool {
        match (tv) {
            case to: TomlObject =>
                for ((sk, sv) in to.value) {
                    if (sv is TomlObject) {
                        return true
                    }
                }
                return false
            case _ => return false
        }
    }

    func isTable(tv: TomlValue): Bool {
        match (tv) {
            case v: TomlArray => return isTableArray(v)
            case v: TomlObject => return true
            case _ => return false
        }
    }

    func isTableArray(ta: TomlArray): Bool {
        if (ta.value.size == 0) {
            return false
        }
        for (v in ta.value) {
            if (!(v is TomlObject)) {
                return false
            }
        }
        return true
    }

    func newline() {
        if (sb.size > 0) {
            sb.append('\n')
        }
    }

    func indentStr(key: Key): String {
        return indentSymbol * (key.size - 1)
    }
}

// ascii escape sequences
let SPECIAL_CHAR_ESCAPES: Array<String> = ["\\u0000", "\\u0001", "\\u0002", "\\u0003", "\\u0004", "\\u0005", "\\u0006",
    "\\u0007", "\\b", "\\t", "\\n", "\\u000b", "\\f", "\\r", "\\u000e", "\\u000f", "\\u0010", "\\u0011", "\\u0012",
    "\\u0013", "\\u0014", "\\u0015", "\\u0016", "\\u0017", "\\u0018", "\\u0019", "\\u001a", "\\u001b", "\\u001c",
    "\\u001d", "\\u001e", "\\u001f", "", "", "\\\"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "", "", "", "", "\\\\", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "\\u007f"]

func quotedReplace(s: String): String {
    let sb = StringBuilder()
    for (r in s.runes()) {
        let codePoint = Int64(UInt32(r))
        if (codePoint < SPECIAL_CHAR_ESCAPES.size && SPECIAL_CHAR_ESCAPES[codePoint] != "") {
            sb.append(SPECIAL_CHAR_ESCAPES[codePoint])
        } else {
            sb.append(r)
        }
    }
    return sb.toString()
}

let DATETIME_REPLACER = [
    ("z", "Z"),
    ("t", "T"),
    (" ", "T")
]

func datetimeReplace(s: String): String {
    var rs = s
    for (r in DATETIME_REPLACER) {
        rs = s.replace(r[0], r[1])
    }
    return rs
}

extend<T> Option<T> {
    public func into(): T {
        match (this) {
            case Some(v) => v
            case None => throw Exception("unreachable")
        }
    }
}
