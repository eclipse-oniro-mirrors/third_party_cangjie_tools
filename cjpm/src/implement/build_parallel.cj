// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjpm.implement

import std.collection.*
import std.collection.concurrent.*
import std.sync.*
import std.fs.*
import std.regex.*
import cjpm.config.*

class ParallelBuilder {
    var buildConfig = BuildConfig()
    var taskMap = HashMap<String, ResolveConfig>()
    let buildMutex = Mutex()
    var successPkgs = ArrayList<String>()
    let queue = LinkedBlockingQueue<(Option<String>, Option<String>, Option<String>, Option<String>, Bool)>()

    init(buildConfig: BuildConfig) {
        this.buildConfig = buildConfig
    }

    func checkDepFuture(dep: String, task: ResolveConfig, futTasks: HashMap<String, Future<Bool>>,
        sem: Semaphore): Bool {
        var fut: Future<Bool>
        synchronized(this.buildMutex) {
            if (!futTasks.contains(dep)) {
                return true
            }
            fut = futTasks[dep]
        }
        if (!fut.get()) {
            sem.release()
            this.queue.add((task.outLogFile, task.errLogFile, None, None, false))
            return false
        }
        return true
    }

    func checkNoChange(depPkg: String): Bool {
        if (buildConfig.rebuildMacros.contains(depPkg)) {
            return false
        }
        let rootPkgName: String = getRootPkgName(depPkg)
        let cjoFile = Path(this.buildConfig.globalConfig.targetDir).join(rootPkgName).join("${depPkg}.cjo").toString()
        if (!fileExists(cjoFile) || !buildConfig.cjoTimeMap.contains(depPkg) || buildConfig.cjoTimeMap[depPkg] !=
            FileInfo(cjoFile).lastModificationTime.toUnixTimeStamp().toSeconds()) {
            return false
        }
        return true
    }

    func build(): Bool {
        let sem = Semaphore(maxParallelSize)
        let futTasks = HashMap<String, Future<Bool>>()

        let logFuture = spawn {
            =>
            var count: Int64 = this.taskMap.size
            var logFlag: Bool = true
            while (count > 0) {
                let (outLogFile, errLogFile, nativeOutLog, nativeErrLog, isNewLog) = this.queue.remove()
                count--
                if (!isNewLog) {
                    continue
                }
                if (!printAllLogs(outLogFile, errLogFile, nativeOutLog, nativeErrLog)) {
                    logFlag = false
                }
            }
            return logFlag
        }

        // Guaranteed valid order follows 'buildConfig.allPackages'
        for (pkgName in this.buildConfig.allPackages) {
            if (!this.taskMap.contains(pkgName)) {
                continue
            }

            sem.acquire()
            let task = this.taskMap[pkgName]
            let future = spawn {
                =>
                for (dep in task.requirePkgs) {
                    if (!this.checkDepFuture(dep, task, futTasks, sem)) {
                        return false
                    }
                }

                if (task.checkDepCjo) {
                    var nochange: Bool = true
                    for (depPkg in task.requirePkgs) {
                        if (!checkNoChange(depPkg)) {
                            nochange = false
                            break
                        }
                    }
                    if (nochange) {
                        sem.release()
                        this.queue.add((None, None, None, None, false))
                        return true
                    }
                }

                if (!deleteLog(task)) {
                    sem.release()
                    this.queue.add((task.outLogFile, task.errLogFile, None, None, false))
                    return false
                }

                var flag: Bool = true
                if (task.targetPlatform && !runTask(task, this.buildConfig.globalConfig.ldPath)) {
                    flag = false
                }
                if (task.nativePlatform && !runTask(task, this.buildConfig.globalConfig.ldPath,
                    isNativeForCross: true)) {
                    flag = false
                }
                sem.release()
                if (task.targetPlatform && task.nativePlatform) {
                    this.queue.add((task.outLogFile, task.errLogFile, task.nativeOutLog, task.nativeErrLog, true))
                } else if (task.targetPlatform) {
                    this.queue.add((task.outLogFile, task.errLogFile, None, None, true))
                } else if (task.nativePlatform) {
                    this.queue.add((None, None, task.nativeOutLog, task.nativeErrLog, true))
                }
                return flag
            }

            synchronized(this.buildMutex) {
                futTasks.add(pkgName, future)
            }
        }

        var isBuilt: Bool = true
        for ((pkgName, task) in futTasks) {
            if (!task.get()) {
                isBuilt = false
            } else {
                successPkgs.add(pkgName)
            }
        }

        if (!logFuture.get()) {
            isBuilt = false
        }

        return isBuilt
    }

    func deleteLog(task: ResolveConfig): Bool {
        var delLog: Bool = true
        if (task.targetPlatform) {
            if (!deleteFile(task.outLogFile)) {
                delLog = false
            }
            if (!deleteFile(task.errLogFile)) {
                delLog = false
            }
        }

        if (task.nativePlatform) {
            if (!deleteFile(task.nativeOutLog)) {
                delLog = false
            }
            if (!deleteFile(task.nativeErrLog)) {
                delLog = false
            }
        }
        return delLog
    }

    func runTask(resolveConfig: ResolveConfig, ldPath: HashSet<String>, isNativeForCross!: Bool = false): Bool {
        let envs: HashMap<String, String> = HashMap<String, String>()
        let ldPathString: String = getNativeLdLibraryConfig(ldPath)
        if (!LD_PATH.isEmpty() && !ldPathString.isEmpty()) {
            envs.add(LD_PATH, ldPathString)
            if (LD_PATH == "Path") {
                envs.add("PATH", ldPathString)
                envs.add("path", ldPathString)
            }
        }
        let args: ArrayList<String> = getCommandArgs(resolveConfig, this.buildConfig, isNativeForCross)
        CUR_PARALLEL_SIZE.fetchAdd(1)
        if (!futJudge(args)) {
            calculateParallel(CUR_PARALLEL_SIZE.load(), args)
        }
        let commandStr: String = makeCompilerCommand(ldPath, args)

        if (this.buildConfig.isVerbose) {
            let verbose: String = "Compiling package `${resolveConfig.fullName}`: ${commandStr}\n"
            if (!isNativeForCross) {
                if (!creatAndWriteFile(resolveConfig.outLogFile, verbose)) {
                    return false
                }
            } else {
                if (!creatAndWriteFile(resolveConfig.nativeOutLog, verbose)) {
                    return false
                }
            }
        }

        var execCmdFlag: Bool = false
        var outFile: File
        var errFile: File
        var outFilePath: String = ""
        var errFilePath: String = ""
        try {
            if (!isNativeForCross) {
                outFilePath = resolveConfig.outLogFile
                errFilePath = resolveConfig.errLogFile
                outFile = File(resolveConfig.outLogFile, OpenMode.Append)
                errFile = File(resolveConfig.errLogFile, OpenMode.Append)
            } else {
                outFilePath = resolveConfig.nativeOutLog
                errFilePath = resolveConfig.nativeErrLog
                outFile = File(resolveConfig.nativeOutLog, OpenMode.Append)
                errFile = File(resolveConfig.nativeErrLog, OpenMode.Append)
            }
        } catch (e: Exception) {
            eprintln(e.message)
            eprintln("Error: create '${outFilePath}' failed")
            return false
        }
        try {
            if (let Some(returnCode) <- execAndToFile(COMPILE_TOOL, args, outFile, errFile, envMap: envs)) {
                if (returnCode == 0) {
                    execCmdFlag = true
                } else {
                    errFile.write(("Error: failed to compile package `${resolveConfig.fullName}`, " +
                        "return code is ${returnCode}\n").toArray())
                }
            } else {
                errFile.write(("Error: failed to compile package `${resolveConfig.fullName}` " +
                    "with exception occurred\n").toArray())
            }
        } catch (e: Exception) {
            eprintln("Error: failed to write error log into ${errFilePath}: ${e.message}")
            execCmdFlag = false
        }
        CUR_PARALLEL_SIZE.fetchSub(1)
        outFile.close()
        errFile.close()

        return execCmdFlag
    }
}

func parallelBuild(res: ModuleResolve, buildConfig: BuildConfig): Bool {
    let parallel = ParallelBuilder(buildConfig)
    res.forEachPkg(
        {
            resolve: ResolveItem =>
            if (buildConfig.isIncremental && !buildConfig.rebuildList.contains(resolve.fullName)) {
                return true
            }

            if (!resolve.hasProdFiles) { // No files to compile, avoid useless cjc invocations
                buildConfig.rebuildList.remove(resolve.fullName)
                return true
            }

            var finalPath = getFinalPath(buildConfig.globalConfig.targetDir, buildConfig.globalConfig.nativeDir,
                resolve.outputType, true, resolve.rootPkgName, buildConfig.requiredForTests)
            var finalLogPath = getLogPath(buildConfig.globalConfig.targetDir, buildConfig.globalConfig.nativeDir, true,
                resolve.rootPkgName)
            if (!createDirectory(finalPath) || !createDirectory(finalLogPath)) {
                return false
            }

            var resolveConfig = ResolveConfig()
            resolveConfig.targetPath = finalPath
            resolveConfig.packagePath = resolve.packagePath
            resolveConfig.fullName = resolve.fullName
            resolveConfig.rootPkgName = resolve.rootPkgName
            resolveConfig.outputType = resolve.outputType
            resolveConfig.compileOption = resolve.compileOption
            resolveConfig.linkOption = resolve.linkOption
            resolveConfig.nativeCompileOption = resolve.nativeCompileOption
            resolveConfig.nativeLinkOption = resolve.nativeLinkOption
            resolveConfig.customizedOption = resolve.customizedOption
            resolveConfig.requirePkgs = resolve.requires
            resolveConfig.targetPlatform = resolve.targetPlatform
            resolveConfig.nativePlatform = resolve.nativePlatform
            resolveConfig.hasTestFiles = resolve.hasTestFiles
            if (buildConfig.isIncremental && resolveConfig.outputType == STATIC_TYPE &&
                buildConfig.indirectRebuilds.contains(resolve.fullName)) {
                resolveConfig.checkDepCjo = true
            }
            resolveConfig.outLogFile = Path(finalLogPath).join("${resolveConfig.fullName}.outlog").toString()
            resolveConfig.errLogFile = Path(finalLogPath).join("${resolveConfig.fullName}.errlog").toString()

            if (resolve.nativePlatform) {
                resolveConfig.nativePath = getFinalPath(buildConfig.globalConfig.targetDir,
                    buildConfig.globalConfig.nativeDir, resolve.outputType, false, resolve.rootPkgName,
                    buildConfig.requiredForTests)
                let nativeLogPath = getLogPath(buildConfig.globalConfig.targetDir, buildConfig.globalConfig.nativeDir,
                    false, resolve.rootPkgName)
                resolveConfig.nativeOutLog = Path(nativeLogPath).join("${resolveConfig.fullName}.outlog").toString()
                resolveConfig.nativeErrLog = Path(nativeLogPath).join("${resolveConfig.fullName}.errlog").toString()
                if (!createDirectory(resolveConfig.nativePath) || !createDirectory(nativeLogPath)) {
                    return false
                }
            }

            parallel.taskMap.add(resolve.fullName, resolveConfig)
            return true
        }
    )

    if (!parallel.taskMap.isEmpty()) {
        buildConfig.isRebuild = true
    }

    let parallelResult: Bool = parallel.build()

    for (r in res.resolves) {
        if (parallel.successPkgs.contains(r.fullName)) {
            r.buildFlag = true
        }
    }

    return parallelResult
}

func printAllLogs(outLogFile: Option<String>, errLogFile: Option<String>, nativeOutLog: Option<String>,
    nativeErrLog: Option<String>): Bool {
    var logFlag: Bool = true
    if (let Some(outLogFile) <- outLogFile) {
        if (fileExists(outLogFile) && !loadLogAndPrint(outLogFile, false)) {
            logFlag = false
        }
    }
    if (let Some(errLogFile) <- errLogFile) {
        if (fileExists(errLogFile) && !loadLogAndPrint(errLogFile, true)) {
            logFlag = false
        }
    }
    if (let Some(nativeOutLog) <- nativeOutLog) {
        if (fileExists(nativeOutLog) && !loadLogAndPrint(nativeOutLog, false)) {
            logFlag = false
        }
    }
    if (let Some(nativeErrLog) <- nativeErrLog) {
        if (fileExists(nativeErrLog) && !loadLogAndPrint(nativeErrLog, true)) {
            logFlag = false
        }
    }
    return logFlag
}

func loadLogAndPrint(file: String, isStderr: Bool): Bool {
    var logStr: String = ""
    unsafe {
        logStr = String.fromUtf8Unchecked(File.readFrom(file))
    }

    if (isStderr) {
        eprint(logStr)
    } else {
        print(logStr)
    }
    return true
}

func getFinalPath(targetDir: String, nativeDir: String, outputType: String, isTargetPlatform: Bool, name: String,
    requiredForTests: Bool): String {
    var res = ""
    if (outputType == EXE_TYPE && !requiredForTests) {
        if (isTargetPlatform) {
            res = Path(targetDir).join(BIN).toString()
        } else {
            res = Path(nativeDir).join(BIN).toString()
        }
    } else {
        if (isTargetPlatform) {
            res = Path(targetDir).join(name).toString()
        } else {
            res = Path(nativeDir).join(name).toString()
        }
    }
    return res
}

func getLogPath(targetDir: String, nativeDir: String, isTargetPlatform: Bool, rootPkgName: String): String {
    var res = ""
    if (isTargetPlatform) {
        res = Path(targetDir).join(".build-logs").join(rootPkgName).toString()
    } else {
        res = Path(nativeDir).join(".build-logs").join(rootPkgName).toString()
    }
    return res
}

func calculateParallel(currentParalla: Int64, args: ArrayList<String>): Unit {
    var thisParallelSize = currentParalla
    let totalParallelSize = getCpus()

    if (currentParalla <= 2) {
        thisParallelSize = totalParallelSize
    } else {
        thisParallelSize = 2 * totalParallelSize / currentParalla
    }
    args.add("-j${thisParallelSize}", at: 0)
}

func futJudge(args: ArrayList<String>): Bool {
    let tmp = args.toString()
    let fut1: Future<Bool> = spawn {
        let regexParallel = Regex("-j[[:space:]]*(?:[[:digit:]]|=[[:digit:]])")
        regexParallel.matches(tmp)
    }
    let fut2: Future<Bool> = spawn {
        tmp.contains("--jobs") || args.contains("-j")
    }
    return (fut1.get() || fut2.get())
}
