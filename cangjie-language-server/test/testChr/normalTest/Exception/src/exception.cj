// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

func test(){
    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
        let lastElement = arrayTest[3]
    } catch (_) {
        print("catch an exception!")
    }
}
func test1(){
    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
        let lastElement = arrayTest[3]
    } catch (e : Error) {
        print("catch an exception!"+ e.getMessage())
    }
}
func test22(){
    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
        let lastElement = arrayTest[3]
    } catch (e : Throwable) {
        print("catch an exception!"+ e.getMessage())
    }
}
func test23(){
    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
        let lastElement = arrayTest[3]
    } catch (e : Exception) {
        print("catch an exception!"+ e.getMessage())
    }
}
////////////////////
func main() {
    try {
    throw ArithmeticException()
    } catch (e: RuntimeException) { // Caught.
    print("RuntimeException and its subtypes can be caught here")
    }
    return 0
}
open class Father1 <: ArithmeticException {
    var father: Int32 = 0
    init(){}
    func whatFather() { print("I am Father") }
}
open class Father <: Exception {
    var father: Int32 = 0
    func whatFather() { print("I am Father") }
}
class ChildOne <: Father {
    var childOne: Int32 = 1
    init(){}

    func whatChildOne() { print("I am ChildOne") }
    func whatChild() { print("I am method in ChildOne") }
}
class ChildTwo <: Father {
    var childTwo: Int32 = 2
    func whatChildTwo() { print("I am ChildTwo") }
    func whatChild() { print("I am method in ChildTwo") }
}

func test2() {
    var a = 1
    func throwE() {
        if (a == 1) {
            throw ChildOne()
        } else {
            throw ChildTwo()
        }
    }
    try {
    throwE()
    } catch (e: ChildOne | ChildTwo) {
        e.whatFather() // ok: e is an object of Father
        print(e.getMessage()) // ok: e is an object of Father
    }

}
/////////////////////////
func f():Int64 {
    var x = 1;
    try {
        return x + x; // Return 2.
    } catch (e: RuntimeException) { // Caught.
        print("RuntimeException and its subtypes can be caught here")
    } finally {
        x = 2;
    }
    return 0
}
func f1():Int64 {
    var x = 1;
    try {
        return x + x; // Return 2.
    } catch (e: RuntimeException) { // Caught.
        print("RuntimeException and its subtypes can be caught here")
    } finally {
        x = 2;
        return x + x; // Return 4
    } // The return value is 4 but not 2.
    return 0
}
///////////////////////
func f3(){
    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
        throw ArithmeticException()
        let temp = arrayTest[0] + 1 // Will never be executed.
    } catch (e: ArithmeticException) {
        print("an arithmeticException happened: " + e.getMessage())
    } finally {
        print("the finally block is executed")
    }
}
////////////////////
enum Result111<TTT> { Success(TTT) | Failure(Throwable) }

func f4(){
    var freshExc: Option<Throwable> = Option<Throwable>.None
    var freshExc1: Option<Throwable> = None

    let arrayTest: RefArray<Int32> = RefArray<Int32>([0, 1, 2])
    try {
    let lastElement = arrayTest[3]
    } catch (e: ArithmeticException | IndexOutOfBoundsException) {
        print("exception info: " + e.getMessage())
    } catch (e: Exception) {
        print("neither ArithmeticException nor ArrayIndexOutOfBoundsException,exception info: " + e.getMessage())
    } finally {
        print("the finally block is executed")
    }
}
