// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package hle.tool

import std.collection.*

enum SExpToken <: ToString {
    | Open // '('
    | Close // ')'
    | Identifier(String)
    | Str(String)
    | Num(Int64)
    | DOT
    | EOS

    public func toString(): String {
        match (this) {
            case Open => "("
            case Close => ")"
            case Identifier(x) => "Identifier(${x})"
            case Str(x) => "Str(\"${x}\")"
            case Num(x) => "Num(${x})"
            case DOT => "."
            case EOS => "EOS"
        }
    }
}

func isAlpha(c: Rune) {
    return c >= r'a' && c <= r'z' || c >= r'A' && c <= r'Z'
}

func isDigit(c: Rune) {
    return c >= r'0' && c <= r'9'
}

class Scanner {
    var pos: Int64 = 0
    let s: Array<Rune>

    Scanner(let input: String) {
        s = input.toRuneArray()
    }

    func peek(): SExpToken {
        skipWhite()
        if (pos >= s.size) {
            return EOS
        }
        let save = pos
        let result = nextToken()
        pos = save
        result
    }

    func nextToken(): SExpToken {
        skipWhite()
        if (pos >= s.size) {
            return EOS
        }
        let c = s[pos]
        match {
            case c == r'(' =>
                pos++
                Open
            case c == r')' =>
                pos++
                Close
            case c == r'.' =>
                pos++
                DOT
            case isAlpha(c) || c == r'_' =>
                let start = pos
                do {
                    pos++
                } while (isAlpha(s[pos]) || isDigit(s[pos]) || s[pos] == r'_' || s[pos] == r'.')
                Identifier(input[start..pos])
            case isDigit(c) =>
                var num = 0
                do {
                    num = num * 10 + Int64(UInt32(s[pos]) - UInt32(r'0'))
                    pos++
                } while (isDigit(s[pos])) // todo: floating numbers?
                Num(num)
            case c == r'"' =>
                let start = pos
                do {
                    pos++
                } while (s[pos] != r'"')
                pos++
                Str(input[start + 1..pos - 1])
            case _ => throw IllegalArgumentException("Unexpected token: ${c}")
        }
    }

    func skipWhite(): Unit {
        while (pos < s.size && (s[pos] == r' ' || s[pos] == r'\t' || s[pos] == r'\n' || s[pos] == r'\r')) {
            pos++
        }
    }
}

/**
 * S-exp parser, input patterns => parsed result, listed as follows:
 *
 * (number) => TsNumber
 * (string) => TsString
 * (boolean) => TsBoolean
 * (bigint) => TsBigInt
 * (symbol) => TsSymbol
 * (object) => TsRawObjectType
 * (unknown) => TsUnknown
 * (any) => TsAny
 * (undefined) => TsUndefined
 * (null) => TsNull
 * (void) => TsVoid
 * (never) => TsNever
 * (array s-exp) => TsArray(parse(s-expr))
 * (StringLiteral value) => TsStringLiteral(value)
 * (NumberLiteral value) => TsNumberLiteral(value)
 * (literal members) => TsTypeLiteral(...)
 * (ref SomeType) => TsTypeRef("SomeType")
 * (ref SomeType s-exp1 s-exp2 ...) => TsTypeRef("SomeType", [T1, T2, ...]), where T1 = parse(s-exp1), T2 = parse(e-exp2), ...
 * (union s-exp1 s-exp2 ...) => TsUnion([T1, T2, ...]), where T1 = parse(s-exp1), T2 = parse(s-exp2), ...
 * (intersection s-exp1 s-exp2 ...) => TsIntersection([T1, T2, ...]), where T1 = parse(s-exp1), T2 = parse(s-exp2), ...
 * (tuple s-exp1 s-exp2 ...) => TsTuple([T1, T2, ...]), where T1 = parse(s-exp1), T2 = parse(s-exp2), ...
 * (function (generics-list) s-exp0 (parameter name1 s-exp1) (parameter name2 s-exp2) ...)
 *      => TsFunction(prase(s-exp0), [TsParameter(name1, parse(s-exp1)), TsParameter(name2, parse(s-exp2)), ...], [generics])
 * (tuple s-exp1 s-exp2 ...)
 * (unsupported info) => TsUnsupportedType(info)
 * (op kind s-exp) // todo
 */
class TypeParser {
    let scanner: Scanner
    TypeParser(expr: String) {
        scanner = Scanner(expr)
    }

    func parse(): TsType {
        let result = parseType()
        let tok = scanner.nextToken()
        match (tok) {
            case EOS => result
            case _ => throw IllegalArgumentException("Syntax error: Unexpected token ${tok}")
        }
        result
    }

    private func parseTypeRef(): TsType {
        var tok = scanner.nextToken()
        let name = StringBuilder()
        if (let Identifier(left) <- tok) {
            name.append(left)
            tok = scanner.peek()
            while (match (tok) {
                    case DOT => true
                    case _ => false
                }) {
                scanner.nextToken() // '.'
                tok = scanner.nextToken() // the right part of the qualified name
                if (let Identifier(right) <- tok) {
                    name.append(".")
                    name.append(right)
                    scanner.peek()
                } else {
                    syntaxError("identifier", tok)
                }
            }
            let args = parseTypeList()
            let nameStr = name.toString()
            if (nameStr == "Array" && args.size == 1) {
                TsArray(args[0])
            } else if (args.size > 0) {
                TsTypeRef(nameStr, args)
            } else {
                TsTypeRef(nameStr)
            }
        } else {
            syntaxError("type name", tok)
        }
    }

    func parseType(): TsType {
        var tok = scanner.nextToken()
        if (let Open <- tok) {}
        else {
            syntaxError("'('", tok)
        }
        tok = scanner.nextToken()
        let result: TsType = match (tok) {
            case Identifier("string") => TsString
            case Identifier("number") => TsNumber
            case Identifier("boolean") => TsBoolean
            case Identifier("bigint") => TsBigInt
            case Identifier("symbol") => TsSymbol
            case Identifier("object") => TsRawObjectType
            case Identifier("unknown") => TsUnknown
            case Identifier("any") => TsAny
            case Identifier("void") => TsVoid
            case Identifier("never") => TsNever
            case Identifier("undefined") => TsUndefined
            case Identifier("null") => TsNull
            case Identifier("StringLiteral") =>
                tok = scanner.nextToken()
                if (let Str(v) <- tok) {
                    TsStringLiteral(v)
                } else {
                    syntaxError("string", tok)
                }
            case Identifier("NumericLiteral") =>
                tok = scanner.nextToken()
                if (let Num(v) <- tok) {
                    TsNumberLiteral(v)
                } else {
                    syntaxError("number", tok)
                }
            case Identifier("ref") => parseTypeRef()
            case Identifier("array") => TsArray(parseType())
            case Identifier("optional") => TsOptional(parseType())
            case Identifier("union") =>
                let args = parseTypeList()
                if (args.size > 0) {
                    TsUnion(args)
                } else {
                    syntaxError("'('", Close)
                }
            case Identifier("intersection") =>
                let args = parseTypeList()
                if (args.size > 0) {
                    TsIntersection(args)
                } else {
                    syntaxError("'('", Close)
                }
            case Identifier("tuple") => TsTuple(parseTypeList())
            case Identifier("function") =>
                let generics = parseGenerics()
                let returnType = parseType()
                let params = parseParameterList()
                TsFunction(returnType, params, generics)
            case Identifier("literal") => TsTypeLiteral(parseMembers())
            case Identifier("unsupported") =>
                tok = scanner.nextToken()
                if (let Identifier(kind) <- tok) {
                    TsUnsupportedType(kind)
                } else {
                    syntaxError("kind", tok)
                }
            case _ => syntaxError("tag", tok)
        }
        tok = scanner.nextToken()
        if (let Close <- tok) {
            result
        } else {
            syntaxError("')'", tok)
        }
    }

    func parseTypeList(): Array<TsType> {
        let args = ArrayList<TsType>()
        var tok = scanner.peek()
        while (match (tok) {
                case Open => true
                case Close => false
                case _ => syntaxError("'(' or ')'", tok)
            }) {
            args.add(parseType())
            tok = scanner.peek()
        }
        args.toArray()
    }

    func parseParameterList(): Array<TsParameter> {
        let params = ArrayList<TsParameter>()
        var tok = scanner.peek()
        while (match (tok) {
                case Open => true
                case Close => false
                case _ => syntaxError("'(' or ')'", tok)
            }) {
            scanner.nextToken() // '('
            tok = scanner.nextToken() // "parameter"
            if (let Identifier("parameter") <- tok) {}
            else {
                syntaxError("'parameter'", tok)
            }
            tok = scanner.nextToken()
            let name = if (let Identifier(x) <- tok) {
                x
            } else {
                syntaxError("name", tok)
            }
            let pType = parseType()
            tok = scanner.peek()
            let optional = match (tok) {
                case Identifier("optional") =>
                    scanner.nextToken()
                    true
                case Close => false
                case _ => syntaxError("')' or optional", tok)
            }
            tok = scanner.nextToken() // ')'
            if (let Close <- tok) {}
            else {
                syntaxError("')'", tok)
            }
            tok = scanner.peek()
            params.add(TsParameter(name, pType, optional))
        }
        params.toArray()
    }

    func parseMembers(): Array<TsMember> {
        let members = ArrayList<TsMember>()
        var tok = scanner.peek()
        while (match (tok) {
                case Open => true
                case Close => false
                case _ => syntaxError("'(' or ')'", tok)
            }) {
            scanner.nextToken() // '('
            tok = scanner.nextToken()
            let member = match (tok) {
                case Identifier("prop") =>
                    tok = scanner.nextToken()
                    let name = if (let Identifier(x) <- tok) {
                        x
                    } else {
                        syntaxError("name", tok)
                    }
                    let mType = parseType()
                    tok = scanner.peek()
                    let optional = match (tok) {
                        case Identifier("optional") =>
                            tok = scanner.nextToken()
                            true
                        case _ => false
                    }
                    TsProperty(name, mType, optional)
                case Identifier("index") =>
                    let keyType = parseType()
                    let valueType = parseType()
                    TsIndexSignature(keyType, valueType)
                case Identifier("call") =>
                    let generics = parseGenerics()
                    let returnType = parseType()
                    let params = parseParameterList()
                    TsCallSignature(returnType, params, generics)
                case _ => syntaxError("'prop' or 'index' or 'call'", tok)
            }
            tok = scanner.nextToken() // ')'
            if (let Close <- tok) {}
            else {
                syntaxError("')'", tok)
            }
            members.add(member)
            tok = scanner.peek()
        }
        members.toArray()
    }

    func parseGenerics() {
        let generics = ArrayList<TsGeneric>()
        var tok = scanner.nextToken()
        if (let Open <- tok) {}
        else {
            syntaxError("'('", tok)
        }
        while (match (scanner.peek()) {
                case Open => true
                case Close => false
                case x => syntaxError("'(' or ')' or identifier", x)
            }) {
            scanner.nextToken() // '('
            tok = scanner.nextToken()
            let name = if (let Identifier(v) <- tok) {
                v
            } else {
                syntaxError("identifier", tok)
            }
            let result = match (scanner.peek()) {
                case Close => TsGeneric(name)
                case Open =>
                    let ty = parseType()
                    TsGeneric(name, constraint: ty)
                case x => syntaxError("'(' or ')'", x)
            }
            tok = scanner.nextToken()
            if (let Close <- tok) {}
            else {
                syntaxError("')'", tok)
            }
            generics.add(result)
            tok = scanner.peek()
        }
        scanner.nextToken() // ')'
        generics.toArray()
    }

    func syntaxError(expect: String, tok: SExpToken) {
        throw IllegalArgumentException("Syntax error: Expected ${expect}, got ${tok}")
    }
}
