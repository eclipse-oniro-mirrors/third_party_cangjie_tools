// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

package cjcov.core

import stdx.encoding.json.*
import std.fs.*
import std.time.*
import std.collection.*
import std.convert.*
import cjcov.util.*
import stdx.serialization.serialization.*

let LOW_COLOR = "LightPink"
let MEDIUM_COLOR = "Yellow"
let HIGH_COLOR = "LightGreen"
let COVERED_COLOR = "LightGreen"
let UNCOVERED_COLOR = "LightPink"
let TAKENBRANCH_COLOR = "Green"
let NOT_TAKENBRANCH_COLOR = "Red"
let MEDIUM_COVERAGE: Float64 = 75.0
let HIGH_COVERAGE: Float64 = 90.0

func covertHtmlStr(lineStr: String): String {
    var newStr = lineStr
    let replaceTbl: ArrayList<(String, String)> = ArrayList<(String, String)>(
        [
            ("&", "&amp;"),
            ("<", "&lt;"),
            (">", "&gt;")
        ]
    )

    for ((old, new) in replaceTbl) {
        newStr = newStr.replace(old, new)
    }

    return newStr
}

// Replace the string, for example, the source string is "...`%ENC%`...", replaceMap["ENC"]=UTF-8,
// then the replaced string is "...UTF-8.. ."
func replaceVar(oldStr: String, replaceMap: HashMap<String, String>): String {
    var newStr: String = oldStr
    for ((k, v) in replaceMap) {
        newStr = newStr.replace("`%${k}%`", v)
    }

    return newStr
}

class Html {
    var rootPage: String = ROOT_PAGE
    var sourcePage: String = SOURCE_PAGE
    var headStyle: String = ""
    var RootRow: String = ROOT_ROW
    var SourceRow: String = SOURCE_ROW
    var version: String = getCjVersion()
    var options: Command
    var rootRowNum = 0
    var srcPageMap: HashMap<String, String> = HashMap<String, String>()

    var covdata: HashMap<String, CoverageData>

    init(covdata: HashMap<String, CoverageData>, options: Command) {
        this.covdata = covdata
        this.options = options
    }

    func getHeadStyle() {
        if (this.headStyle != "") {
            return this.headStyle
        }

        var headStyleMap: HashMap<String, String> = HashMap<String, String>(
            [
                ("LOW_COLOR", LOW_COLOR),
                ("MEDIUM_COLOR", MEDIUM_COLOR),
                ("HIGH_COLOR", HIGH_COLOR),
                ("COVERED_COLOR", COVERED_COLOR),
                ("UNCOVERED_COLOR", UNCOVERED_COLOR),
                ("TAKENBRANCH_COLOR", TAKENBRANCH_COLOR),
                ("NOT_TAKENBRANCH_COLOR", NOT_TAKENBRANCH_COLOR)
            ]
        )

        this.headStyle = replaceVar(HEAD_STYLE, headStyleMap)

        return this.headStyle
    }

    func getDateTime(): String {
        var now = DateTime.now()
        return now.format("yyyy-MM-dd HH:mm:ss")
    }

    func getRootPage() {
        return this.rootPage
    }

    func getSourcePage(srcFileName: String): String {
        return this.srcPageMap[srcFileName]
    }

    func getFileCoverageDataMap(input: HashMap<String, String>, fileData: CoverageData): HashMap<String, String> {
        var rowMap = input

        var (lineTotal, lineExec, lineCoverage) = fileData.coverage()
        rowMap["LINES_EXEC"] = lineExec.toString()
        rowMap["LINES_TOTAL"] = lineTotal.toString()
        rowMap["LINES_COVERAGE_RATE"] = "100"
        if (lineTotal == 0) {
            rowMap["LINES_COVERAGE"] = "-"
            rowMap["LINES_BAR"] = "green"
        } else {
            rowMap["LINES_COVERAGE"] = lineCoverage.format(".1") + " %"
            rowMap["LINES_COVERAGE_RATE"] = lineCoverage.format(".1")
            rowMap["LINES_BAR"] = coverageToBarColor(lineCoverage)
            rowMap["LINES_COLOR"] = coverageToColor(lineCoverage)
        }

        var (branchTotal, branchExec, branchCoverage) = fileData.coverage(showBranch: true)
        rowMap["ROOT_ROW_BRANCHES_INFO"] = "-"
        rowMap["BRANCHES_COVERAGE"] = "-"
        rowMap["BRANCHES_COLOR"] = HIGH_COLOR
        if (options.branches) {
            rowMap["ROOT_ROW_BRANCHES_INFO"] = branchExec.toString() + " /" + branchTotal.toString()
            if (branchTotal > 0) {
                rowMap["BRANCHES_COVERAGE"] = branchCoverage.format(".1") + " %"
                rowMap["BRANCHES_COLOR"] = coverageToColor(branchCoverage)
            }
        }

        rowMap["BAR_BORDER"] = ""
        if (lineCoverage < 1e-7) {
            rowMap["BAR_BORDER"] = "border:white; "
        }

        return rowMap
    }

    func getRootRow(): String {
        var rowArr: ArrayList<String> = ArrayList<String>()
        var rowMap: HashMap<String, String> = HashMap<String, String>()
        var srcFileNums = this.covdata.size
        let srcFileNames: ArrayList<String> = ArrayList<String>(srcFileNums)

        // Get a sorted srcFileNames
        for ((srcFileName, _) in this.covdata) {
            srcFileNames.add(srcFileName)
        }

        srcFileNames.sortBy(comparator: cmp, stable: true)
        for (srcFileName in srcFileNames) {
            var hd = this.covdata[srcFileName]
            rowMap.clear()

            rootRowNum++
            if (rootRowNum % 2 == 0) {
                rowMap["ALTSTYLE"] = #"style="background-color:LightSteelBlue""#
            } else {
                rowMap["ALTSTYLE"] = ""
            }

            var relSrcFileName = hd.getRelSrcFileName(this.options)

            // Replace some special char with '_', so that the html file can jump rightly.
            var htmlName = replaceSpecialChar(relSrcFileName) + ".html"
            if (!this.options.htmldetail) {
                rowMap["FILE_NAME"] = relSrcFileName
            } else {
                rowMap["FILE_NAME"] = #"<a href=""# + htmlName + "\">" + relSrcFileName + "</a>"
            }

            rowMap = getFileCoverageDataMap(rowMap, hd)

            rowArr.add(replaceVar(this.RootRow, rowMap))
        }

        return String.join(rowArr.toArray(), delimiter: " ")
    }

    func setRootPageBranchData(dataInput: HashMap<String, String>): HashMap<String, String> {
        var data = dataInput

        var branchTotal = 0
        var branchCovered = 0
        var branchCoverage = Float64(0.0)

        // The branch coverage option data is generated only when the user specifies the --branch option
        if (this.options.branches) {
            for (fname in this.covdata.keys()) {
                var (total, covered, _) = this.covdata[fname].coverage(showBranch: true)
                branchTotal += total
                branchCovered += covered
            }

            branchCoverage = calculateCoverage(branchCovered, branchTotal)
        }

        appendBranchInfo(data, branchCovered, branchTotal, branchCoverage, this.options.branches)

        return data
    }

    func setRootPageLineData(dataInput: HashMap<String, String>): HashMap<String, String> {
        var data = dataInput

        var lineTotal = 0
        var lineCovered = 0
        for (fname in covdata.keys()) {
            var (total, covered, _) = covdata[fname].coverage()
            lineTotal += total
            lineCovered += covered
        }
        var lineCoverage = calculateCoverage(lineCovered, lineTotal)

        data["LINES_EXEC"] = lineCovered.toString()
        data["LINES_TOTAL"] = lineTotal.toString()
        if (lineTotal == 0) {
            data["LINES_COVERAGE"] = "-"
            data["LINES_COLOR"] = HIGH_COLOR
        } else {
            data["LINES_COVERAGE"] = lineCoverage.format(".1") + " %"
            data["LINES_COLOR"] = coverageToColor(lineCoverage)
        }

        return data
    }

    func replaceRootPage() {
        var data: HashMap<String, String> = HashMap<String, String>()

        data["HEAD"] = "Cangjie Code Coverage Report"
        data["VERSION"] = this.version
        data["DATE"] = getDateTime()
        data["FILE_NUMBER"] = this.covdata.size.toString()
        data["LOW_COLOR"] = LOW_COLOR
        data["MEDIUM_COLOR"] = MEDIUM_COLOR
        data["HIGH_COLOR"] = HIGH_COLOR
        data["COVERAGE_MED"] = MEDIUM_COVERAGE.format(".1")
        data["COVERAGE_HIGH"] = HIGH_COVERAGE.format(".1")

        data = setRootPageBranchData(data)
        data = setRootPageLineData(data)

        data["CSS"] = getHeadStyle()
        data["ROWS"] = this.getRootRow()

        this.rootPage = replaceVar(this.rootPage, data)

        return
    }

    func getSourceRow(lineno: Int64, lineStr: String, cData: CoverageData): String {
        var rowStr = SOURCE_ROW
        var data: HashMap<String, String> = HashMap<String, String>()
        data["LINE_NUMBER"] = lineno.toString()

        if (!cData.branches.contains(lineno)) {
            data["LINE_BRANCH"] = ""
        } else {
            var branchMap: HashMap<String, String> = HashMap<String, String>()
            var branchTemplate = BRANCH_DETAIL
            var branchData = cData.branches[lineno]
            branchMap["BRANCH_CONTENTS"] = ""

            var takenCnt = 0

            for ((branch, taken) in branchData) {
                if (taken > 0) {
                    takenCnt += 1
                    branchMap["BRANCH_CONTENTS"] += #"<div class="takenBranch">&check; Branch "# + branch.toString() +
                        " taken " + taken.toString() + " times.</div>"
                } else {
                    branchMap["BRANCH_CONTENTS"] += #"<div class="notTakenBranch">&cross; Branch "# + branch.toString() +
                        " not taken.</div>"
                }
            }

            branchMap["BRANCH_SUMMARY"] = takenCnt.toString() + "/" + branchData.size.toString()

            data["LINE_BRANCH"] = replaceVar(branchTemplate, branchMap)
        }

        if (cData.covered.contains(lineno)) {
            data["COV_CLASS"] = "coveredLine"
            data["LINE_COUNT"] = "Y"
        } else if (cData.uncovered.contains(lineno)) {
            data["COV_CLASS"] = "uncoveredLine"
            data["LINE_COUNT"] = "N"
        } else {
            data["COV_CLASS"] = ""
            data["LINE_COUNT"] = ""
        }

        data["SOURCE"] = covertHtmlStr(lineStr)

        rowStr = replaceVar(rowStr, data)

        return rowStr
    }

    func replaceSourcePage() {
        var sourceHtmlStr: String

        var data: HashMap<String, String> = HashMap<String, String>()

        for ((fname, covCls) in this.covdata) {
            data.clear()

            var srcFilename = covCls.getSrcFileName()

            data["HEAD"] = "Cangjie Code Coverage Report"
            data["VERSION"] = this.version
            data["DATE"] = getDateTime()
            data["CSS"] = getHeadStyle()
            data["LOW_COLOR"] = LOW_COLOR
            data["MEDIUM_COLOR"] = MEDIUM_COLOR
            data["HIGH_COLOR"] = HIGH_COLOR
            data["COVERAGE_MED"] = MEDIUM_COVERAGE.format(".1")
            data["COVERAGE_HIGH"] = HIGH_COVERAGE.format(".1")

            data["FILENAME"] = covCls.getRelSrcFileName(this.options)

            var (lineTotal, lineCovered, lineCoverage) = covdata[fname].coverage()
            data["LINES_EXEC"] = lineCovered.toString()
            data["LINES_TOTAL"] = lineTotal.toString()
            if (lineTotal == 0) {
                data["LINES_COVERAGE"] = "-"
                data["LINES_COLOR"] = HIGH_COLOR
            } else {
                data["LINES_COVERAGE"] = lineCoverage.format(".1") + " %"
                data["LINES_COLOR"] = coverageToColor(lineCoverage)
            }

            var (branchTotal, branchCovered, branchCoverage) = covdata[fname].coverage(showBranch: true)
            appendBranchInfo(data, branchCovered, branchTotal, branchCoverage, this.options.branches)

            var rows: ArrayList<String> = ArrayList<String>()
            var fileLines = getFileLines(srcFilename)
            var count = 1
            for (line in fileLines) {
                rows.add(this.getSourceRow(count, line.trimAsciiEnd(), covdata[fname]))
                count += 1
            }

            data["ROWS"] = String.join(rows.toArray(), delimiter: "\n")

            sourceHtmlStr = replaceVar(this.sourcePage, data)
            this.srcPageMap.add(srcFilename, sourceHtmlStr)
        }
    }
}

func appendBranchInfo(data: HashMap<String, String>, branchCovered: Int64, branchTotal: Int64, branchCoverage: Float64,
    branchFlag: Bool): Unit {
    data["BRANCHES_EXEC"] = "-"
    data["BRANCHES_TOTAL"] = "-"
    data["BRANCHES_COVERAGE"] = "-"
    data["BRANCHES_COLOR"] = HIGH_COLOR
    if (branchFlag) {
        data["BRANCHES_EXEC"] = branchCovered.toString()
        data["BRANCHES_TOTAL"] = branchTotal.toString()
        if (branchTotal > 0) {
            data["BRANCHES_COVERAGE"] = branchCoverage.format(".1") + " %"
            data["BRANCHES_COLOR"] = coverageToColor(branchCoverage)
        }
    }
    return
}

func writeHtml(strWrite: String, fpath: String): Bool {
    if (strWrite == "") {
        eprintln("get a empty string, generate html: ${fpath} failed.")
        return false
    }

    File.writeTo(fpath, unsafe { strWrite.rawData() })
    return true
}

func coverageToColor(coverage: Float64): String {
    if (coverage < MEDIUM_COVERAGE) {
        return LOW_COLOR
    } else if (coverage < HIGH_COVERAGE) {
        return MEDIUM_COLOR
    } else {
        return HIGH_COLOR
    }
}

func coverageToBarColor(coverage: Float64): String {
    if (coverage < MEDIUM_COVERAGE) {
        return "red"
    } else if (coverage < HIGH_COVERAGE) {
        return "yellow"
    } else {
        return "green"
    }
}

func getHtmlPath(path: String, sourceName!: String = ""): String {
    var outputPath = path.removeSuffix(getSep())
    if (sourceName.size == 0) {
        return outputPath + getSep() + "index.html"
    }

    // Replace some special char with '_', so that the html file can jump rightly.
    return outputPath + getSep() + replaceSpecialChar(sourceName) + ".html"
}

public func genHtmlReport(covdata: HashMap<String, CoverageData>, options: Command): Bool {
    var htmlCls = Html(covdata, options)
    var rootHtmlName = getHtmlPath(options.output)

    htmlCls.replaceRootPage()

    if (!writeHtml(htmlCls.getRootPage(), rootHtmlName)) {
        eprintln("write root html:${rootHtmlName} failed")
        return false
    }

    // If not get --htmldetail option, not generate html report separately for each source file.
    if (!options.htmldetail) {
        return true
    }
    htmlCls.replaceSourcePage()

    for ((srcFileName, covCls) in covdata) {
        var relSrcFileName = covCls.getRelSrcFileName(options)
        var newSourcePage = htmlCls.getSourcePage(srcFileName)

        var sourceHtmlName = getHtmlPath(options.output, sourceName: relSrcFileName)
        if (!writeHtml(newSourcePage, sourceHtmlName)) {
            eprintln("write source html:${sourceHtmlName} failed")
            return false
        }
    }

    return true
}

public func genXmlReport(covdata: HashMap<String, CoverageData>, options: Command) {
    var lineTotal = 0
    var lineExec = 0
    var branchTotal = 0
    var branchExec = 0

    for (fname in covdata.keys()) {
        var (total, covered, _) = covdata[fname].coverage()
        lineTotal += total
        lineExec += covered
    }

    if (options.branches) {
        for (fname in covdata.keys()) {
            var (total, covered, _) = covdata[fname].coverage(showBranch: true)
            branchTotal += total
            branchExec += covered
        }
    }

    let replaceMap: HashMap<String, String> = HashMap<String, String>(
        [
            ("XML_LINE_EXEC", lineExec.toString()),
            ("XML_LINE_TOTAL", lineTotal.toString()),
            ("XML_BRANCHES_EXEC", branchExec.toString()),
            ("XML_BRANCHES_TOTAL", branchTotal.toString())
        ]
    )

    let xmlStr = replaceVar(XML_DETAIL, replaceMap)
    File.writeTo(
        options.output + getSep() + "coverage.xml",
        unsafe { xmlStr.rawData() }
    )

    return
}

public func genJsonReport(covdata: HashMap<String, CoverageData>, options: Command) {
    var filePathList: ArrayList<String> = ArrayList<String>()
    for (fname in covdata.keys()) {
        filePathList.add(fname)
    }
    filePathList.sortBy(comparator: cmp, stable: true)

    var fileListJson = FileListJson()
    for (fname in filePathList) {
        let (total, _, _) = covdata[fname].coverage()
        let hitLines = covdata[fname].covered
        let relPath = covdata[fname].getRelSrcFileName(options)
        fileListJson.addItem(FileJson(relPath, total, hitLines))
    }

    let fileStr: String = fileListJson.serialize().toJson().toJsonString().replace("\\u0026", "&")
    let jsonPath = options.output + getSep() + "coverage.json"

    var file = try {
        File(jsonPath, Write)
    } catch (e: Exception) {
        eprintln("Error: create '${jsonPath}' failed")
        return
    }
    file.write(unsafe { fileStr.rawData() })
    file.close()

    return
}
