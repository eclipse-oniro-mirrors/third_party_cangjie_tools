// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

package cjpm.toml

import std.collection.*

enum LEXSTATE <: Hashable & Equatable<LEXSTATE> {
    | LEXNIL
    | LEXTOP
    | LEXTOPEND
    | LEXTABLESTART
    | LEXTABLEEND
    | LEXARRAYTABLEEND
    | LEXTABLENAMESTART
    | LEXTABLENAMEEND
    | LEXBARENAME
    | LEXQUOTEDNAME
    | LEXKEYSTART
    | LEXKEYEND
    | LEXKEYNAMESTART
    | LEXVALUE
    | LEXARRAYVALUE
    | LEXARRAYVALUEEND
    | LEXARRAYEND
    | LEXINLINETABLEVALUE
    | LEXINLINETABLEVALUEEND
    | LEXINLINETABLEEND
    | LEXSTRING
    | LEXMULTILINESTRING
    | LEXRAWSTRING
    | LEXMULTILINERAWSTRING
    | LEXMULTILINESTRINGESCAPE
    | LEXSTRINGESCAPE
    | LEXHEXESCAPE
    | LEXSHORTUNICODEESCAPE
    | LEXLONGUNICODEESCAPE
    | LEXNUMBERORDATESTART
    | LEXNUMBERORDATE
    | LEXDATETIME
    | LEXPARTIALTIME
    | LEXHEXINTEGER
    | LEXOCTALINTEGER
    | LEXBINARYINTEGER
    | LEXDECIMALNUMBER
    | LEXDECIMALNUMBERSTART
    | LEXBASENUMBERORDATE
    | LEXFLOAT
    | LEXBOOL
    | LEXCOMMENTSTART
    | LEXCOMMENT

    public func value(): Int64 {
        match (this) {
            case LEXNIL => 0
            case LEXTOP => 1
            case LEXTOPEND => 2
            case LEXTABLESTART => 3
            case LEXTABLEEND => 4
            case LEXARRAYTABLEEND => 5
            case LEXTABLENAMESTART => 6
            case LEXTABLENAMEEND => 7
            case LEXBARENAME => 8
            case LEXQUOTEDNAME => 9
            case LEXKEYSTART => 10
            case LEXKEYEND => 11
            case LEXKEYNAMESTART => 12
            case LEXVALUE => 13
            case LEXARRAYVALUE => 14
            case LEXARRAYVALUEEND => 15
            case LEXARRAYEND => 16
            case LEXINLINETABLEVALUE => 17
            case LEXINLINETABLEVALUEEND => 18
            case LEXINLINETABLEEND => 19
            case LEXSTRING => 20
            case LEXMULTILINESTRING => 21
            case LEXRAWSTRING => 22
            case LEXMULTILINERAWSTRING => 23
            case LEXMULTILINESTRINGESCAPE => 24
            case LEXSTRINGESCAPE => 25
            case LEXHEXESCAPE => 26
            case LEXSHORTUNICODEESCAPE => 27
            case LEXLONGUNICODEESCAPE => 28
            case LEXNUMBERORDATESTART => 29
            case LEXNUMBERORDATE => 30
            case LEXDATETIME => 31
            case LEXHEXINTEGER => 32
            case LEXOCTALINTEGER => 33
            case LEXBINARYINTEGER => 34
            case LEXDECIMALNUMBER => 35
            case LEXDECIMALNUMBERSTART => 36
            case LEXBASENUMBERORDATE => 37
            case LEXFLOAT => 38
            case LEXBOOL => 39
            case LEXCOMMENTSTART => 40
            case LEXCOMMENT => 41
            case LEXPARTIALTIME => 42
        }
    }

    public func hashCode(): Int64 {
        return this.value().hashCode()
    }

    public operator func ==(rhs: LEXSTATE): Bool {
        return this.value() == rhs.value()
    }

    public operator func !=(rhs: LEXSTATE): Bool {
        return this.value() != rhs.value()
    }
}

type StateFn = (Lexer) -> LEXSTATE

let TRANSITIONS = HashMap<LEXSTATE, StateFn>(
    [
        (LEXTOP, LexStateMachine.lexTop),
        (LEXTOPEND, LexStateMachine.lexTopEnd),
        (LEXTABLESTART, LexStateMachine.lexTableStart),
        (LEXTABLEEND, LexStateMachine.lexTableEnd),
        (LEXARRAYTABLEEND, LexStateMachine.lexArrayTableEnd),
        (LEXTABLENAMESTART, LexStateMachine.lexTableNameStart),
        (LEXTABLENAMEEND, LexStateMachine.lexTableNameEnd),
        (LEXBARENAME, LexStateMachine.lexBareName),
        (LEXQUOTEDNAME, LexStateMachine.lexQuotedName),
        (LEXKEYSTART, LexStateMachine.lexKeyStart),
        (LEXKEYEND, LexStateMachine.lexKeyEnd),
        (LEXKEYNAMESTART, LexStateMachine.lexKeyNameStart),
        (LEXVALUE, LexStateMachine.lexValue),
        (LEXARRAYVALUE, LexStateMachine.lexArrayValue),
        (LEXARRAYVALUEEND, LexStateMachine.lexArrayValueEnd),
        (LEXARRAYEND, LexStateMachine.lexArrayEnd),
        (LEXINLINETABLEVALUE, LexStateMachine.lexInlineTableValue),
        (LEXINLINETABLEVALUEEND, LexStateMachine.lexInlineTableValueEnd),
        (LEXINLINETABLEEND, LexStateMachine.lexInlineTableEnd),
        (LEXSTRING, LexStateMachine.lexString),
        (LEXMULTILINESTRING, LexStateMachine.lexMultilineString),
        (LEXRAWSTRING, LexStateMachine.lexRawString),
        (LEXMULTILINERAWSTRING, LexStateMachine.lexMultilineRawString),
        (LEXMULTILINESTRINGESCAPE, LexStateMachine.lexMultilineStringEscape),
        (LEXSTRINGESCAPE, LexStateMachine.lexStringEscape),
        (LEXHEXESCAPE, LexStateMachine.lexHexEscape),
        (LEXSHORTUNICODEESCAPE, LexStateMachine.lexShortUnicodeEscape),
        (LEXLONGUNICODEESCAPE, LexStateMachine.lexLongUnicodeEscape),
        (LEXNUMBERORDATESTART, LexStateMachine.lexNumberOrDateStart),
        (LEXNUMBERORDATE, LexStateMachine.lexNumberOrDate),
        (LEXDATETIME, LexStateMachine.lexDatetime),
        (LEXHEXINTEGER, LexStateMachine.lexHexInteger),
        (LEXOCTALINTEGER, LexStateMachine.lexOctalInteger),
        (LEXBINARYINTEGER, LexStateMachine.lexBinaryInteger),
        (LEXDECIMALNUMBER, LexStateMachine.lexDecimalNumber),
        (LEXDECIMALNUMBERSTART, LexStateMachine.lexDecimalNumberStart),
        (LEXBASENUMBERORDATE, LexStateMachine.lexBaseNumberOrDate),
        (LEXFLOAT, LexStateMachine.lexFloat),
        (LEXBOOL, LexStateMachine.lexBool),
        (LEXCOMMENTSTART, LexStateMachine.lexCommentStart),
        (LEXCOMMENT, LexStateMachine.lexComment),
        (LEXNIL, nil)
    ]
)

func nil(_: Lexer) {
    return LEXNIL
}

class LexStateMachine {
    static func process(lex: Lexer, state: LEXSTATE): LEXSTATE {
        let sa = TRANSITIONS.get(state)
        match (sa) {
            case Some(a) => return a(lex)
            case _ => ()
        }
        return LEXNIL
    }

    static func lexTop(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isWhitespace(c) || isNL(c)) {
            return lexSkip(lex, LEXTOP)
        }
        match (c) {
            case r'#' =>
                lex.push(LEXSTATE.LEXTOP)
                return LEXSTATE.LEXCOMMENTSTART
            case r'[' => return LEXSTATE.LEXTABLESTART
            case r'\u{00}' =>
                if (lex.pos > lex.start) {
                    return lex.errorf("unexpected EOF")
                }
                lex.emit(ITEMTYPE.EOF)
                return LEXNIL
            case _ => ()
        }
        lex.backup()
        lex.push(LEXTOPEND)
        return LEXKEYSTART
    }

    static func lexTopEnd(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case c == r'#' =>
                lex.push(LEXSTATE.LEXTOP)
                return LEXSTATE.LEXCOMMENTSTART
            case isWhitespace(c) => return LEXSTATE.LEXTOPEND
            case isNL(c) =>
                lex.ignore()
                return LEXSTATE.LEXTOP
            case c == TOML_EOF =>
                lex.emit(ITEMTYPE.EOF)
                return LEXNIL
            case _ => ()
        }
        return lex.errorf("expected a top-level item to end with a newline, comment, or EOF, but got ${c} instead")
    }

    static func lexTableStart(lex: Lexer): LEXSTATE {
        if (lex.peek() == r'[') {
            lex.next()
            lex.emit(ITEMTYPE.ARRAYTABLESTART)
            lex.push(LEXARRAYTABLEEND)
        } else {
            lex.emit(ITEMTYPE.TABLESTART)
            lex.push(LEXTABLEEND)
        }
        return LEXTABLENAMESTART
    }

    static func lexTableEnd(lex: Lexer): LEXSTATE {
        lex.emit(ITEMTYPE.TABLEEND)
        return LEXTOPEND
    }

    static func lexArrayTableEnd(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (c != r']') {
            return lex.errorf("expected end of table array name delimiter ']', but got ${c} instead")
        }
        lex.emit(ITEMTYPE.ARRAYTABLEEND)
        return LEXTOPEND
    }

    static func lexTableNameStart(lex: Lexer): LEXSTATE {
        lex.skip(isWhitespace)
        let c = lex.peek()
        match {
            case c == r']' || c == TOML_EOF => return lex.errorf(
                "unexpected end of table name (table names cannot be empty)")
            case c == r'.' => return lex.errorf("unexpected table separator (table names cannot be empty)")
            case c == r'"' || c == r'\'' =>
                lex.ignore()
                lex.push(LEXTABLENAMEEND)
                return LEXQUOTEDNAME
            case _ =>
                lex.push(LEXTABLENAMEEND)
                return LEXBARENAME
        }
    }

    static func lexTableNameEnd(lex: Lexer): LEXSTATE {
        lex.skip(isWhitespace)
        let c = lex.next()
        match {
            case isWhitespace(c) => return LEXTABLENAMEEND
            case c == r'.' =>
                lex.ignore()
                return LEXTABLENAMESTART
            case c == r']' => return lex.pop()
            case _ => return lex.errorf("expected '.' or ']' to end table name, but got ${c} instead")
        }
    }

    static func lexBareName(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isBareKeyChar(c)) {
            return LEXBARENAME
        }
        lex.backup()
        lex.emit(ITEMTYPE.TEXT)
        return lex.pop()
    }

    static func lexQuotedName(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) => return lexSkip(lex, LEXVALUE)
            case c == r'"' =>
                lex.ignore()
                return LEXSTRING
            case c == r'\'' =>
                lex.ignore()
                return LEXRAWSTRING
            case c == TOML_EOF => return lex.errorf("unexpected EOF; expected value")
            case _ => return lex.errorf("expected value but found ${c} instead")
        }
    }

    static func lexKeyStart(lex: Lexer): LEXSTATE {
        lex.skip(isWhitespace)
        let c = lex.peek()
        match {
            case c == r'=' || c == TOML_EOF => return lex.errorf("unexpected '=': key name appears blank")
            case c == r'.' => return lex.errorf("unexpected '.': keys cannot start with a '.'")
            case c == r'"' || c == r'\'' => lex.ignore()
            case _ => ()
        }
        lex.emit(ITEMTYPE.KEYSTART)
        return LEXKEYNAMESTART
    }

    static func lexKeyNameStart(lex: Lexer): LEXSTATE {
        lex.skip(isWhitespace)
        let c = lex.peek()
        match {
            case c == r'=' || c == TOML_EOF => return lex.errorf("unexpected '='")
            case c == r'.' => return lex.errorf("unexpected '.'")
            case c == r'"' || c == r'\'' =>
                lex.ignore()
                lex.push(LEXKEYEND)
                return LEXQUOTEDNAME
            case _ =>
                lex.push(LEXKEYEND)
                return LEXBARENAME
        }
    }

    static func lexKeyEnd(lex: Lexer): LEXSTATE {
        lex.skip(isWhitespace)
        let c = lex.next()
        match {
            case isWhitespace(c) => return lexSkip(lex, LEXKEYEND)
            case c == TOML_EOF => return lex.errorf("unexpected EOF; expected key separator '='")
            case c == r'.' =>
                lex.ignore()
                return LEXKEYNAMESTART
            case c == r'=' =>
                lex.emit(ITEMTYPE.KEYEND)
                return lexSkip(lex, LEXVALUE)
            case _ => return lex.errorf("expected '.' or '=', but got ${c} instead")
        }
    }

    static func lexValue(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) => return lexSkip(lex, LEXVALUE)
            case isDigit(c) =>
                lex.backup()
                return LEXNUMBERORDATESTART
            case c == r'[' =>
                lex.ignore()
                lex.emit(ITEMTYPE.ARRAY)
                return LEXARRAYVALUE
            case c == r'{' =>
                lex.ignore()
                lex.emit(ITEMTYPE.INLINETABLESTART)
                return LEXINLINETABLEVALUE
            case c == r'"' =>
                if (lex.accept(r'"')) {
                    if (lex.accept(r'"')) {
                        lex.ignore()
                        return LEXMULTILINESTRING
                    }
                    lex.backup()
                }
                lex.ignore()
                return LEXSTRING
            case c == r'\'' =>
                if (lex.accept(r'\'')) {
                    if (lex.accept(r'\'')) {
                        lex.ignore()
                        return LEXMULTILINERAWSTRING
                    }
                    lex.backup()
                }
                lex.ignore()
                return LEXRAWSTRING
            case c == r'.' => return lex.errorf("floats must start with a digit, not '.'")
            case c == r'i' || c == r'n' =>
                if ((lex.accept(r'n') && lex.accept(r'f')) ||
                    (lex.accept(r'a') && lex.accept(r'n'))) {
                    lex.emit(ITEMTYPE.FLOAT)
                    return lex.pop()
                }
            case c == r'-' || c == r'+' => return LEXDECIMALNUMBERSTART
            case isLetter(c) =>
                lex.backup()
                return LEXBOOL
            case c == TOML_EOF => return lex.errorf("unexpected EOF; expected value")
            case _ => return lex.errorf("expected '.' or '=', but got ${c} instead")
        }
        return lex.errorf("expected value, but got ${c} instead")
    }

    static func lexArrayValue(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) || isNL(c) => return lexSkip(lex, LEXARRAYVALUE)
            case c == r'#' =>
                lex.push(LEXARRAYVALUE)
                return LEXCOMMENTSTART
            case c == r',' => return lex.errorf("unexpected comma")
            case c == r']' => return LEXARRAYEND
            case _ => ()
        }
        lex.backup()
        lex.push(LEXARRAYVALUEEND)
        return LEXVALUE
    }

    static func lexArrayValueEnd(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) || isNL(c) => return lexSkip(lex, LEXARRAYVALUEEND)
            case c == r'#' =>
                lex.push(LEXARRAYVALUEEND)
                return LEXCOMMENTSTART
            case c == r',' =>
                lex.ignore()
                return LEXARRAYVALUE
            case c == r']' => return LEXARRAYEND
            case _ => return lex.errorf("expected a comma (',') or array terminator (']'), but got ${charOrEOF(c)}")
        }
    }

    static func lexArrayEnd(lex: Lexer): LEXSTATE {
        lex.ignore()
        lex.emit(ITEMTYPE.ARRAYEND)
        return lex.pop()
    }

    static func lexInlineTableValue(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) => return lexSkip(lex, LEXINLINETABLEVALUE)
            case isNL(c) => return lex.errorPrevLine(LexException("errLexInlineTableNL"))
            case c == r'#' =>
                lex.push(LEXINLINETABLEVALUE)
                return LEXCOMMENTSTART
            case c == r',' => return lex.errorf("unexpected comma")
            case c == r'}' => return LEXINLINETABLEEND
            case _ => ()
        }
        lex.backup()
        lex.push(LEXINLINETABLEVALUEEND)
        return LEXKEYSTART
    }

    static func lexInlineTableValueEnd(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isWhitespace(c) => return lexSkip(lex, LEXINLINETABLEVALUEEND)
            case isNL(c) => return lex.errorPrevLine(LexException("errLexInlineTableNL"))
            case c == r'#' =>
                lex.push(LEXINLINETABLEVALUEEND)
                return LEXCOMMENTSTART
            case c == r',' =>
                lex.ignore()
                lex.skip(isWhitespace)
                if (lex.peek() == r'}') {
                    return lex.errorf("trailing comma not allowed in inline tables")
                }
                return LEXINLINETABLEVALUE
            case c == r'}' => return LEXINLINETABLEEND
            case _ => lex.errorf("expected a comma or an inline table terminator '}', but got ${charOrEOF(c)} instead")
        }
    }

    static func lexInlineTableEnd(lex: Lexer): LEXSTATE {
        lex.ignore()
        lex.emit(ITEMTYPE.INLINETABLEEND)
        return lex.pop()
    }

    static func lexString(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case c == TOML_EOF => return lex.errorf("unexpected EOF; expected '\"'")
            case isNL(c) => return lex.errorPrevLine(LexException("errLexStringNL"))
            case c == r'\\' =>
                lex.push(LEXSTRING)
                return LEXSTRINGESCAPE
            case c == r'"' =>
                lex.backup()
                lex.emit(ITEMTYPE.STRING)
                lex.next()
                lex.ignore()
                return lex.pop()
            case _ => ()
        }
        return LEXSTRING
    }

    static func lexMultilineString(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case c == TOML_EOF => return lex.errorf(###"unexpected EOF; expected '"""'"###)
            case c == r'\\' => return LEXMULTILINESTRINGESCAPE
            case c == r'"' =>
                if (lex.accept(r'"')) {
                    if (lex.accept(r'"')) {
                        if (lex.peek() == r'"') {
                            if (lex.current().endsWith(###"""""""###) && lex.current().endsWith(###"\""""""###)) {
                                return lex.errorf(###"unexpected EOF; expected '"""""""###)
                            }
                            lex.backup()
                            lex.backup()
                            return LEXMULTILINESTRING
                        }
                        lex.backup()
                        lex.backup()
                        lex.backup()
                        lex.emit(ITEMTYPE.MULTILINESTRING)
                        lex.next()
                        lex.next()
                        lex.next()
                        lex.ignore()
                        return lex.pop()
                    }
                    lex.backup()
                }
                return LEXMULTILINESTRING
            case _ => return LEXMULTILINESTRING
        }
    }

    static func lexRawString(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case c == TOML_EOF => return lex.errorf(###"unexpected EOF; expected "'""###)
            case isNL(c) => return lex.errorPrevLine(LexException("errLexStringNL"))
            case c == r'\'' =>
                lex.backup()
                lex.emit(ITEMTYPE.RAWSTRING)
                lex.next()
                lex.ignore()
                return lex.pop()
            case _ => return LEXRAWSTRING
        }
    }

    static func lexMultilineRawString(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case c == TOML_EOF => return lex.errorf(###"unexpected EOF; expected "'''""###)
            case c == r'\'' =>
                if (lex.accept(r'\'')) {
                    if (lex.accept(r'\'')) {
                        if (lex.peek() == r'\'') {
                            if (lex.current().endsWith("'''''")) {
                                return lex.errorf(###"unexpected "''''''""###)
                            }
                            lex.backup()
                            lex.backup()
                            return LEXMULTILINERAWSTRING
                        }
                        lex.backup()
                        lex.backup()
                        lex.backup()
                        lex.emit(ITEMTYPE.RAWMULTILINESTRING)
                        lex.next()
                        lex.next()
                        lex.next()
                        lex.ignore()
                        return lex.pop()
                    }
                    lex.backup()
                }
                return LEXMULTILINERAWSTRING
            case _ => return LEXMULTILINERAWSTRING
        }
    }

    static func lexMultilineStringEscape(lex: Lexer): LEXSTATE {
        if (isNL(lex.next())) {
            return LEXMULTILINESTRING
        }
        lex.backup()
        lex.push(LEXMULTILINESTRING)
        return LEXSTRINGESCAPE
    }

    static func lexStringEscape(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match (c) {
            case r'e' | r'b' | r't' | r'n' | r'f' | r'r' | r'"' | r' ' | r'\t' | r'\\' => return lex.pop()
            case r'x' => return LEXHEXESCAPE
            case r'u' => return LEXSHORTUNICODEESCAPE
            case r'U' => return LEXLONGUNICODEESCAPE
            case _ => return lex.error(LexException("errLexEscape ${c}"))
        }
    }

    static func lexHexEscape(lex: Lexer): LEXSTATE {
        var c: Rune
        for (_ in 0..2) {
            c = lex.next()
            if (!isHexadecimal(c)) {
                return lex.errorf("expected two hexadecimal digits after '\\x', but got ${lex.current()} instead")
            }
        }
        return lex.pop()
    }

    static func lexShortUnicodeEscape(lex: Lexer): LEXSTATE {
        var c: Rune
        for (_ in 0..4) {
            c = lex.next()
            if (!isHexadecimal(c)) {
                return lex.errorf("expected four hexadecimal digits after '\\u', but got ${lex.current()} instead")
            }
        }
        return lex.pop()
    }

    static func lexLongUnicodeEscape(lex: Lexer): LEXSTATE {
        var c: Rune
        for (_ in 0..8) {
            c = lex.next()
            if (!isHexadecimal(c)) {
                return lex.errorf("expected four hexadecimal digits after '\\U', but got ${lex.current()} instead")
            }
        }
        return lex.pop()
    }

    static func lexNumberOrDateStart(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (c == r'0') {
            return LEXBASENUMBERORDATE
        }
        if (!isDigit(c)) {
            return lex.errorf("expected a digit but got ${c} instead")
        }
        return LEXNUMBERORDATE
    }

    static func lexNumberOrDate(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isDigit(c)) {
            return LEXNUMBERORDATE
        }
        match (c) {
            case r'-' | r':' => return LEXDATETIME
            case r'_' => return LEXDECIMALNUMBER
            case r'.' | r'e' | r'E' => return LEXFLOAT
            case _ => ()
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexDatetime(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isDigit(c)) {
            return LEXDATETIME
        }
        match (c) {
            case r'-' | r':' | r'T' | r't' | r' ' | r'.' | r'Z' | r'z' | r'+' => return LEXDATETIME
            case _ => ()
        }
        lex.backup()
        lex.emit(ITEMTYPE.DATETIME)
        return lex.pop()
    }

    static func lexHexInteger(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isHexadecimal(c)) {
            return LEXHEXINTEGER
        }
        if (c == r'_') {
            return LEXHEXINTEGER
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexOctalInteger(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isOctal(c)) {
            return LEXOCTALINTEGER
        }
        if (c == r'_') {
            return LEXOCTALINTEGER
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexBinaryInteger(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isBinary(c)) {
            return LEXBINARYINTEGER
        }
        if (c == r'_') {
            return LEXBINARYINTEGER
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexDecimalNumber(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isDigit(c)) {
            return LEXDECIMALNUMBER
        }
        match (c) {
            case r'.' | r'e' | r'E' => return LEXFLOAT
            case r'_' => return LEXDECIMALNUMBER
            case _ => ()
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexDecimalNumberStart(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match (c) {
            case r'i' =>
                if (!lex.accept(r'n') || !lex.accept(r'f')) {
                    return lex.errorf("invalid float: '${lex.current()}'")
                }
                lex.emit(ITEMTYPE.FLOAT)
                return lex.pop()
            case r'n' =>
                if (!lex.accept(r'a') || !lex.accept(r'n')) {
                    return lex.errorf("invalid float: '${lex.current()}'")
                }
                lex.emit(ITEMTYPE.FLOAT)
                return lex.pop()
            case r'0' =>
                let p = lex.peek()
                match (p) {
                    case r'b' | r'o' | r'x' => return lex.errorf(
                        "cannot use sign with non-decimal numbers: '${lex.current()}${p}'")
                    case _ => ()
                }
            case r'.' => return lex.errorf("floats must start with a digit, not '.'")
            case _ => ()
        }
        if (isDigit(c)) {
            return LEXDECIMALNUMBER
        }
        return lex.errorf("expected a digit but got ${c}")
    }

    static func lexBaseNumberOrDate(lex: Lexer): LEXSTATE {
        var c = lex.next()
        if (isDigit(c)) {
            return LEXNUMBERORDATE
        }
        match (c) {
            case r'_' => return LEXDECIMALNUMBER
            case r'.' | r'e' | r'E' => return LEXFLOAT
            case r'b' =>
                c = lex.peek()
                if (!isBinary(c)) {
                    return lex.errorf("not an binary number: '${lex.current()}${c}'")
                }
                return LEXBINARYINTEGER
            case r'o' =>
                c = lex.peek()
                if (!isOctal(c)) {
                    return lex.errorf("not an octal number: '${lex.current()}${c}'")
                }
                return LEXOCTALINTEGER
            case r'x' =>
                c = lex.peek()
                if (!isHexadecimal(c)) {
                    return lex.errorf("not an hexidecimal number: '${lex.current()}${c}'")
                }
                return LEXHEXINTEGER
            case _ => ()
        }
        lex.backup()
        lex.emit(ITEMTYPE.INTEGER)
        return lex.pop()
    }

    static func lexFloat(lex: Lexer): LEXSTATE {
        let c = lex.next()
        if (isDigit(c)) {
            return LEXFLOAT
        }
        match (c) {
            case r'_' | r'.' | r'-' | r'+' | r'e' | r'E' => return LEXFLOAT
            case _ => ()
        }
        lex.backup()
        lex.emit(ITEMTYPE.FLOAT)
        return lex.pop()
    }

    static func lexBool(lex: Lexer): LEXSTATE {
        let cs = StringBuilder()
        while (true) {
            let c = lex.next()
            if (!isLetter(c)) {
                lex.backup()
                break
            }
            cs.append(c)
        }
        let s = cs.toString()
        if (s == "true" || s == "false") {
            lex.emit(ITEMTYPE.BOOL)
            return lex.pop()
        }
        return lex.errorf("expected bool value but found ${s} instead")
    }

    static func lexCommentStart(lex: Lexer): LEXSTATE {
        lex.ignore()
        lex.emit(ITEMTYPE.COMMENTSTART)
        return LEXCOMMENT
    }

    static func lexComment(lex: Lexer): LEXSTATE {
        let c = lex.next()
        match {
            case isNL(c) || c == TOML_EOF =>
                lex.backup()
                lex.emit(ITEMTYPE.TEXT)
                return lex.pop()
            case _ => return LEXCOMMENT
        }
    }

    static func lexSkip(lex: Lexer, nextState: LEXSTATE): LEXSTATE {
        lex.ignore()
        return nextState
    }
}
