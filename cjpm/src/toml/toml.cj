// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

package cjpm.toml

import std.collection.*
import std.fs.*
import std.io.*
import stdx.serialization.serialization.*

public interface ToToml {
    static func fromToml(tv: TomlValue): DataModel
    func toToml(): TomlValue
}

extend DataModel <: ToToml {
    public static func fromToml(tv: TomlValue): DataModel {
        match (tv) {
            case v: TomlString => DataModelString(v.value)
            case v: TomlInteger => DataModelInt(v.value)
            case v: TomlFloat => DataModelFloat(v.value)
            case v: TomlBoolean => DataModelBool(v.value)
            case v: TomlOffsetDatetime => DataModelString(v.toString())
            case v: TomlLocalDatetime => DataModelString(v.toString())
            case v: TomlLocalDate => DataModelString(v.toString())
            case v: TomlLocalTime => DataModelString(v.toString())
            case v: TomlArray => buildDMSeq(v)
            case v: TomlObject => buildDMStruct(v)
            case _ => throw TomlException("not supported TomlValue ${tv}")
        }
    }

    public func toToml(): TomlValue {
        match (this) {
            case dmb: DataModelBool => return TomlBoolean(dmb.getValue())
            case dmi: DataModelInt => return TomlInteger(dmi.getValue())
            case dmf: DataModelFloat => return TomlFloat(dmf.getValue())
            case dmstr: DataModelString => return TomlString(dmstr.getValue())
            case dmseq: DataModelSeq => return toToml(dmseq)
            case dms: DataModelStruct => return toToml(dms)
            case _ => throw TomlException("Unmatched DataModel type!")
        }
    }

    private static func buildDMSeq(ta: TomlArray): DataModelSeq {
        var dms: DataModelSeq = DataModelSeq()
        var list: ArrayList<DataModel> = dms.getItems()
        var ti = ta.value
        for (i in 0..ti.size) {
            var dm: DataModel = fromToml(ti[i])
            list.add(dm)
        }
        return dms
    }

    private static func buildDMStruct(jo: TomlObject): DataModelStruct {
        var dms: DataModelStruct = DataModelStruct()
        var list: ArrayList<Field> = dms.getFields()
        var map: LinkedHashMap<String, TomlValue> = jo.value
        for ((str, tv) in map) {
            var dm: DataModel = fromToml(tv)
            var field: Field = Field(str, dm)
            list.add(field)
        }
        return dms
    }

    private func toToml(dmseq: DataModelSeq): TomlArray {
        var ta: TomlArray = TomlArray()
        var ti = dmseq.getItems()
        for (i in 0..ti.size) {
            var value: TomlValue = ti[i].toToml()
            ta.append(value)
        }
        return ta
    }

    private func toToml(dms: DataModelStruct): TomlObject {
        var to: TomlObject = TomlObject()
        var ti = dms.getFields()
        for (i in 0..ti.size) {
            let fie = ti[i]
            var value: TomlValue = fie.getData().toToml()
            to.put(fie.getName(), value)
        }
        return to
    }
}

public func unmarshal<T>(path: String): T where T <: Serializable<T> {
    var e = Exception("")
    try (fin = File(path, Read)) {
        let de = Decoder(fin)
        let to = de.decode()
        let dm = DataModel.fromToml(to)
        return T.deserialize(dm)
    } catch (ex: Exception) {
        e = ex
    }
    throw e
}

public func marshal<T>(object: T): Array<Byte> where T <: Serializable<T> {
    let dm = object.serialize()
    let bs = ByteBuffer()
    let enc = Encoder(bs)
    enc.encode(dm)
    return bs.bytes()
}
