// Copyright (c) Huawei Technologies Co., Ltd. 2025. All rights reserved.
// This source file is part of the Cangjie project, licensed under Apache-2.0
// with Runtime Library Exception.
//
// See https://cangjie-lang.cn/pages/LICENSE for license information.

func CaptureFunc() {
    /**
    * this var xxxxx
    */
    var varXXX = 1
    /**
    * this let xxxxx
    */
    let letYYY = 2
    /**
    * this func ggggg
    */
    func closure() {
        return varXXX + letYYY // OK, captured a mutable variable.
    }
    
    let b = closure  // Error, g cannot be assigned to a variable

    closure    // Error, g cannot be used as an expression
    closure()  // OK, g can be invoked

    func g2() {
        closure()        // OK, g2 also captured a mutable variable
    }

    let c = g2 // Error, g2 cannot be assigned to a variable

    func h() {
        return letYYY  // OK, captured an immutable variable.
    }
    let d = h    // OK, h can be assigned to variable

    // Error, lambda captured a mutable variable,
    //cannot be assigned to a variable
    let e = { return varXXX }

    // OK, lambda captured a mutable variable, can be invoked.
    let i = { varXXX*varXXX }()

    return closure  // Error, g cannot be used as a return value.
}

/*
    捕获的局部变量必须满足以下规则：
    • 被捕获的局部变量必须在闭包定义之前声明，否则编译报错；
    • 变量被捕获时必须已经完成初始化，否则编译报错；
    • 如果函数外有变量，同时函数内有同名的局部变量，函数内的闭包因局部变量的作用域未开始而捕获
    了函数外的变量时，为避免用户误用，报warning；
*/

// 1. The captured variable must be defined before the closure.
let letGlobal_1 = 4
func f_1() {
    letGlobal_1 // Print 4.
    let x_2 = 99
    func f_1_1() {
        return x_2
    }
    let f_2_2 = {
        return x_2
    }
    f_1_1() // Print 99.
    f_2_2() // Print 99.
}

// 2. The variable must be initialized before being captured.
let let_variable = 4
func f_2() {
    let_variable// Print 4.
    let let_variable: Int64
    func f_2_1() {
        return let_variable  // Error: x is not initialized yet.
    }
    let_variable = 99
    f_2_1()
}
// 3. If there is a local variable in a block, closures capture variables of the same name in the outer scope will report a warning.
let let_variable_1 = 4
func f_3() {
    let_variable_1 // Print 4.
    func f_3_1() {
        return let_variable_1 // warning
    }
    let f_3_2 = {
        return let_variable_1 // warning
    }
    let let_variable_1 = 99
    f_3_1() // print 4
    f_3_2() // print 4
}

//全局变量、静态成员变量、实例成员变量的访问可以分为以下两种情形：
//• 对于静态成员变量和全局变量在函数或lambda 中均可以访问；
//• 实例成员函数将this 作为参数传入，因此在实例成员函数内可以通过this 访问所有的实例成员变量。
//因此访问了var 修饰的全局变量、静态成员变量、实例成员变量的函数或lambda 仍可作为一等公民使
//用。
// 1. Static member variables and global variables can be accessed in functions.
class C {
    static var a: Int32 = 0
    static func foo() {
        a++ // OK
        return a
    }
}
var globalV1 = 0
func countGlobalV1() {
    globalV1++ // OK
    C.a = 99 // OK
    let g = C.foo // OK
}
